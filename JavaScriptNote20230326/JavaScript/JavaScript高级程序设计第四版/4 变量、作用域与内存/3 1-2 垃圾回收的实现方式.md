# 3.1-2 垃圾回收的实现方式

# 2.3.1 标记清理

## 描述

- 实现JavaScript的最常见的垃圾回收策略就是标记清理（mark-ans-sweep）
- [函数中的局部变量的正常生命周期](../4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98.md) 中举到的垃圾回收例子实现时就可以使用标记清理

## 标记清理例子

1. 当变量进入上下文，如在函数中声明了一个变量
2. 在函数上下文的变量会被加上**存在于当前上下文的标记**
3. 该上下文中的变量逻辑上永远不应该释放它们的内存，只要当前上下文中的代码在运行
4. 当变量离开上下文（函数执行完毕，当前上下文由函数上下文变为父上下文），变量会被加上**离开上下文的标记**
5. 上下文改变完毕，有离开上下文的标记的变量被垃圾回收程序回收

## 变量加标记方式

- 给变量加上标记的过程实际上不重要，重要的是标记清理的策略
    - 当变量进行上下文时，反转某一位（表明该变量被标记）
    - 或者维护“在上下文”和“不在上下文中”两个变量列表，上下文切换时，将变量标记从一个列表移动到另一个列表

## 标记清理的浏览器实现

- 浏览器的垃圾回收程序运行时，会标记所有内存中存储的所有变量（标记方法不重要）
- 然后它会将所有在上下文中的变量以及在上下文中的**变量引用的变量**的标记去掉
- 在此之后，再被加上标记的变量就是待删除的，因为任何上下文的变量都访问不了它们了
- 随后垃圾回收程序做一次**内存清理，**销毁带标记的所有值并回收它们的内存

---

- 解释：
    - 当前内存中所有存储的变量就是声明过的变量，标记它们表示它们都是有可能是被清除的变量
    - 将所有作用域链中的上下文的变量对象中的变量以及上下文中的变量引用的变量标记去掉，表示它们都是存在当前上下文需要的变量，不能被清除
    - 这个时候仍然被标记的变量就是之前已经执行过的上下文声明的变量，现有的上下文已经不能访问它们的变量了，需要被清除
- 各大浏览器（谷歌，欧鹏，火狐，IE，Safari）都在自己的JavaScript实现中采用标记清理（或变体）的策略，只是在运行垃圾回收的频率上有所差异

# 2.3.2 引用记数

## 描述

- 不常用的垃圾回收策略**引用计数（reference counting）**
- 对每个值都记录它被引用的次数
- 声明变量时，变量的引用计数为1
- 如果同一个值又被赋值给另一个变量，那么引用数加1
- 如果保存该值引用的变量被其他值覆盖了，引用数减1
- 当一个值的引用数为0时，没办法访问这个值了，可以**安全**地回收了
- 垃圾回收程序下次运行时就会释放引用值为0的值的内存

## 缺点

- 引用计数的策略最早由Netscape Navigator 3.0 采用，但是遇到了一个问题：**循环引用**
- 循环引用：对象A有一个指针指向对象B，而对象B有一个指针指向对象A，如下
    
    ```jsx
    function problem() {
      let objA = {};
      let objB = {};
      objA["B"] = objB;
      objB["A"] = objA;
      console.log(objA);
      console.log(objB);
    }
    problem();
    ```
    
    - objA和objB在函数上下文时，引用数都是2，声明一次，被赋值再加1次
    - 再函数执行结束后，上下文中没有objA和objB，引用数都减去1，但是它们的引用数没有变为0，所以在程序中永远不会被清理，因为它们**循环引用**了
    - 而标记清理就不会出现这种问题，因为函数执行后，上下文中没有这两个变量，无法访问到，它们被标记之后会被垃圾回收程序清理
    
    ---
    
    - 在node环境和浏览器环境，二者的打印结果不一样
        - node环境
            
            ```jsx
            <ref *1> { B: { A: [Circular *1] } }
            <ref *1> { A: { B: [Circular *1] } }
            ```
            
        - 浏览器环境（现代（102.0.5005.115）谷歌浏览器）会无限循环嵌套下去
            
            ![Untitled](3%201-2%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/Untitled.png)
            

## 使用引用计数的浏览器版本

- IE8及之前的IE，不是所有的对象都是原生的JavaScript对象
    - BOM和DOM是C++实现的组件对象模型（COM，Component Object Model）
    - COM使用引用计数实现垃圾回收
    - 原生的JavaScript对象使用标记清理
- 在IE8及之前，只要涉及COM对象，就无法避开循环引用问题
    
    ```jsx
    let ele = document.getElementById("some_element"); // COM
    let myObject = new Object(); // 原生JavaScript对象
    myObject.ele = ele; 
    ele.mo = myObject; // 构成循环引用
    ```
    
    - DOM对象和一个原生JavaScript对象之间制造了循环引用
    - DOM元素永远不会被回收，因为它使用引用计数实现垃圾回收，引用数不可能为0
- 避免循环引用的方法
    - 切断原生JavaScript对象和DOM元素之间的连接
        
        ```jsx
        ele.mo = null;
        myObject.ele = null;
        ```
        
    - 设置成null，会切断变量与之前引用值的关系
    - 下次垃圾回收程序运行时，这些值被删除，内存被回收
- IE9将BOM和DOM修改为JavaScript原生对象，避免了两套垃圾回收算法的问题，同时消除内存泄漏现象

## 注意

- 导致循环引用的情况不只这一种方式
# 2.2 变量声明

# 2.2.1 使用var的函数作用域声明

## 描述

- 使用var声明变量，**变量自动被添加到最接近的上下文的变量对象中**
    - 浏览器环境下，var声明的变量挂载到window上
    - node环境下，var声明的变量**不会**挂载到global下
- **最接近的上下文要么是全局上下文，要么是函数的局部上下文**
- 在with语句中，因为只是指定了临时上下文的变量对象，在其中用var声明变量，这个变量会添加到临时上下文外最接近的上下文的变量对象中

## 函数作用域中声明var变量

- 在函数作用域中声明的var变量是函数的局部变量
- 在函数执行完毕后被销毁,这点在[3.变量](../3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md) 中阐述过
    
    ```jsx
    function add(num1, num2) {
    	var sum = num1 + num2;
    	return sum;
    }
    let result = add(10, 20);
    console.log(sum); // 报错，未识别的sum
    ```
    

## 在函数作用域中省略var

- 在函数作用域中省略var声明一个变量，这个变量会变为全局变量，被添加到全局上下文
- 严格模式下这种声明方式会报错，[3.变量](../3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md) 中阐述过
    
    ```jsx
    function add(num1, num2) {
    	sum = num1 + num2;
    	return sum;
    }
    let result = add(10, 20);
    console.log(sum); // 30
    ```
    

## var的状态提升

- 状态提示即使用var声明的变量默认提示在上下文最顶部执行，例如
    
    ```jsx
    let a = 123;
    var name = "456";
    ```
    
    等价于
    
    ```jsx
    var name;
    let a = 123;
    name = "456";
    ```
    
    ⇒ 在`let a = 123` 语句之前大于使用name都不会报错误，但是会**被当作undefined处理**
    
- **状态提升只是提升了声明，而没有提升赋值**

## 重复声明

- 由于状态提升的特性，使用var在同级上下文重复声明同一个变量并不会报错
- 因为状态提示，所有声明都想当与在上下文顶部声明一下变量，而赋值的位置不变，例如
    
    ```jsx
    var name = 789;
    let a = 123;
    var name = 456;
    let b = 456;
    var name = a;
    ```
    
    等价于
    
    ```jsx
    **var name; // 状态提升**
    name = 789
    let a = 123;
    name = 456;
    let b = 456;
    name = a;
    ```
    
    - 在`let a` 和 `let b` 前，中，后打印name会得到不同的值
    - 状态提升只是提升声明，没有提升赋值

# 2.2.2 使用let的块级作用域声明

[let特性](../3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md) 中提到过let的特性与使用方式

## 描述

- ES6新增的关键字，用于声明变量，和var相似，但作用域是块级的
- 块级作用域是JavaScript的新概念，它**由最近的一对花括号{}界定**
- if块，while块，function块，甚至只使用花括号的单独的块也是let声明的作用域

## 不能重复声明

- let不能在同一块级作用域声明两次相同变量，因为var可以状态提升，而let没有
- 重复声明会抛出SyntaxError(语法错误)
    
    ```jsx
    let b = 2;
    if(true) {
    	let b = 3; // 不会报错
    	let b = 4; // 报错 同一作用域中有相同变量 不能重复声明 SyntaxError
    }
    ```
    

## 适合作为迭代变量

- let是块作用域，在循环中是局部变量，循环结束后被销毁，对循环外部上下文没有影响
- var是函数作用域，在循环中声明后变为全局变量，循环结束后不会被销毁，对循环外部上下文有影响
    
    ```jsx
    for(var i = 0; i < 0; i++) {};
    console.log(i); // 10
    
    for(let i = 0; i < 0; i++) {};
    console.log(i); // 未定义ReferenceError
    ```
    

## 暂时性死区

[暂时性死区](../3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md) 中有关于let的暂时性死区、全局声明、[条件声明](../3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md)等说明

- temporal dead zone
- 在一个使用let声明的变量时，对于这个变量而言，之前的部分就是暂时性死区
- 实际上let也有状态提升，因为暂时性死区的原因，在声明之前不能使用let声明的变量

# 2.2.3 使用const的常量声明

- ES6新增的const关键字，const声明的变量必须初始化为某个值，之后不能再被重新赋值
- 除了常量这个特性外，其它的和let的特性一样

## 和let的区别

- 唯一区别：在声明时必须初始化，且不能再被赋值
- 其它和let一样：块作用域、不能重复声明，适合做for…of的迭代常量、暂时性死区

## 适合保存对象引用

- const声明的变量适合初始化为对象
- 因为**const声明只应用到顶级原语或者对象、**
    - 赋值为对象的const变量不能再被赋值
    - 但是对象的键不受影响，可以修改
    
    ```jsx
    const o1 = {}
    o.name = "mangwu";
    ```
    
- 如果想让整个对象都不被修改，可以使用**Object.freeze()**方法
    - 给**对象修改属性值时虽然不会报错，但是会静默失败**
        
        ```jsx
        const o = Object.freeze({});
        o.name = "mangwu";// 不会报错
        console.log(o); // {}  修改属性失败
        
        ```
        

## JavaScript引擎处理const变量

- 因为const变量保存的值是不变的（对象的引用不变）
    - JavaScript运行时编译器可以将const变量的实例都替换成实际的值
    - 不会通过查询表进行变量查找
    - 谷歌的V8引擎就是执行了这种优化
- 基于这种情况，开发流程不会因为声明const受到影响，**编写代码时应该多使用const**
- 关于声明变量的使用情况，[3.4 声明变量的代码风格](../3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md) 中有提及
    
    
    ## 3.4 声明变量的代码风格
    
    - ES6的新声明变量的关键字进一步规范了JavaScript的书写，有助于提升代码质量
    - ES6新增声明关键字的使用实践
        1. 不使用**var**
            1. var的函数作用域范围比let的块作用域大，会导致变量渗透
            2. 使用let和const能**明确作用域、声明位置、和值限制**
        2. const 优先，let次之
            1. 静态代码分析工具提前发现不合法赋值操作
            2. 优先使用const能让开发者更有信心推断某些变量的值不会改变

# 2.2.4 标识符查找

## 描述

- 标识符查找指
    - 在特定上下文位读取或写入而引入一个标识符时，必须通过搜索确定这个标识符表示什么
    - 例如在表达式中使用一个变量，那么程序就会在当前上下文搜索该变量，并读取该变量的值以便执行表达式
- 搜索过程和作用域链有关
    1. 开始于作用域链前端，以给定的名称搜索对应的标识符
    2. 如果**在局部上下文的变量对象有该标识符，则搜索停**止，变量确定
        1. 作用域链的每个变量对象也有原型链
        2. 搜索涉及到每个对象的原型链
    3. 如果没有找到变量名，则继续沿着作用域链搜索
    4. 直到搜索到全局上下文的变量对象
    5. 如果仍然没有找到，说明没有定义该标识符，会报错

## 例子

- 可以查看[上述关于上下文中代码执行原理过于抽象，可以对一个简单的例子加以解析](../4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98.md) 中关于上下文代码执行的原理
    
    
    - 上述关于上下文中代码执行原理过于抽象，可以对一个简单的例子加以解析
        
        ```jsx
        var color = "blue";
        function changeColor() {
        	if(color == "blue") {
        		color = "red";
        	} else {
        		color = "blue";
        	}
        }
        changeColor();
        ```
        
        - 函数changeColor的作用域链包含两个变量对象：
            - 函数自己的变量对象（即参数定义的arguments对象，即使没有参数）
            - 另一个就是全局上下文的变量对象
        - 这个函数能够找到color，原因
            - 先从作用域链的最前端（函数自己的变量对象）开始查找，没有往后查找
            - 作用域链中的第二个（也是最后一个）变量对象就是全局上下文的变量对象，其中有通过var定义的color变量
            - 这就**完成了一次通过作用域链逐级搜索标识符名称解析变量的过程**
- 如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用**父上下文**的同名标识符
    
    ```jsx
    var color = "red";
    function getColor(){
    	let color = "blue';
    	console.log(color); // 这个时候引用的color就不能引用到父上下文的color了
    	return color;
    }
    ```
    
- 唯一的例外是，再浏览器环境下，color是挂载再window变量对象下的，所以可以使用`window.color` 引用全局上下文的color

---

## 注意

- 标识符这种通过作用域链从局部上下文的变量对象到父上下文的变量对象直到全局上下文的变量对象的查找方式，是一种标识符越在外层，耗费越大的搜寻方式；
    - 访问局部变量比访问全局变量更快，因为不用切换作用域
    - 不过JavaScript引擎在优化标识符查找上做了很多工作，现在这个差异微不足道
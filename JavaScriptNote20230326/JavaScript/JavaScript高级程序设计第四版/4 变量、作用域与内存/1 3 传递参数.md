# 1.3 传递参数

ECMAScript中的所有函数的参数都是**按值传递**的

# 描述

- 函数的所有参数都是按值传递
- 函数外部的值会被**复制到函数内部的参数**中

# 原理

- 因为变量的访问方式有**按值**访问和**按引用**访问两种方式，函数值传递的方式**只有按值**传递，所以传参时根据参数是引用值还是原始值进行区分即可

## 函数传递原理

- 无论传入的是原始值变量还是引用值变量，值都会被复制到一个局部变量中
- 这个局部变量是一个命名参数，就是arguments对象中的一个槽位
    
    ```jsx
    function test() {
    	console.log(arguments);
    }
    const a = {}
    test(23, "mangwu", a);
    // 打印结果
    [Arguments] { '0': 23, '1': 'mangwu', '2': {} }
    ```
    

## 传入原始值

- 由于原始值的访问时按值访问的，那么传递后，参数也是一个原始值，且是传递变量原始值的副本
- 参数变量中的值和传入值相同，但是相互独立，互不影响
- **参数是一个局部变量**，传入原始值不影响外部的变量
    
    ```jsx
    function getZero(num) {
      num -= num;
      return num;
    }
    let num = 10;
    getZero(num);
    console.log(num); // 不会改变
    ```
    

## 传入引用值

- 引用值的访问按引用访问，传递后，参数也是一个引用值，是传递变量原始保存的指针副本
- 所以通过参数变量保存的指针，就可以改变外部声明的引用值对象（改变保存在堆内存中的对象）
- **参数是一个局部变量**，但是参数是引用值，执行外部的一个引用值对象，所以传入引用值可能改变外部引用值变量指向的对象
    
    ```jsx
    function setName(person) {
      person.name = "wumang";
    }
    const person = {
      name: "manwu",
      age: 23,
    };
    setName(person);
    console.log(person); //   { name: 'wumang', age: 23 }
    ```
    
    ⇒ 传入引用值，改变了外部对象的属性
# 3. 语言基础

- JavaScript的语言基础，包括
    - 语法
    - 数据结构
    - 流控制语句
    - 函数
- 任何语言的核心都是描述这门语言在基本层面上如何工作的，这些基本层面由ECMA-262规定
- ECMA-262第五版规定的ECMAScript是以伪语言形式规定了JavaScript的核心，它也是目前浏览器支持最好的版本
- ES6在浏览器实现程度次之，但在2017年底，几乎所有现代浏览器都全部支持了ES6，所以以ES6语法为标准讲解

# 1.语法

ECMAScript的语法很大程度上借鉴了C语言和其他类C语言，特别是Java和Perl。ECMAScript具有宽松的弱类型语法

## 1.1区分大小写

- ECMAScript中的语法中的一切都区分大小写
    - 变量
    - 函数名
    - 操作符
- 例如typeof是一个函数名，且不能作为变量名（关键字），但是Typeof完全可以是一个变量名

## 1.2 标识符

- **标识（zhi）符**，就是指变量、函数、属性或函数参数的名称，其构成
    - 第一个字符必须是一个字母、下划线（_）或者美元($)符号
    - 剩下的字符由字母、下划线、美元符号和数字组成
- 字母范围
    - 可以是扩展ASCII中的字母，即`[a-zA-Z]`
    - 也可以是Unicode中的字母字符，如æ，α等，但不推荐使用
- 标识符写法规范
    - 一般而言，ECMAScript标识符使用**驼峰**标识法
    - 对于变量，函数，属性，函数参数都是以第一个单词首字母小写，后面每个单词首字母大写的形式，如
        
        ```jsx
        var firstSecond;
        var thisIsAObject = {
        	myName: "mangwu",
        	myAge: 22
        };
        function sayHi(yourName) {
        	console.log("Hi!" + yourName);
        }
        ```
        
    - 对于类，使用大驼峰标识法，所有单词的首字母大写
        
        ```jsx
        class IsAClass extends Object {
        	constructor(name, age){
        		this.name = name;
        		this.age = age;
        	}
        }
        ```
        
- 关键字、保留字、true、false和null不能作为标识符

## 1.3 注释

- ECMAScript使用单行注释和多行注释
    - 单行注释：使用两个斜杠字符开头
        
        ```jsx
        // 单行注释
        ```
        
    - 多行注释：以一个斜杠加星号（*）开头，以一个星号（*）和斜杠结尾
        
        ```jsx
        /* 多行
         * 注释
         */
        ```
        

## 1.4 严格模式

- ECMAScript第五版增加了严格模式（strict mode）的概念：
    - 严格模式是一种不同的JavaScript解析和执行模型
    - 对于**ES3中不规范的JavaScript写法**以及**不安全的活动**进行限制并抛出错误
    - 默认不会启用严格模式，在脚本开头加上use strict启用严格模式
        
        ```jsx
        "use strict";
        ```
        
- `"use strict"` 其实是一个预处理指令
    - 任何支持JavaScript的环境（不限于浏览器）看到它都会切换到严格模式
    - 使用预处理指令是为了不破坏ES3的语法
- 也可以将其封装到一个函数中执行
    
    ```jsx
    function() tranferStrictMode() {
    	"use strict";
    }
    ```
    
- 严格模式会影响到JavaScript执行的许多方面，所有现代浏览器都支持

## 1.5语句特性

- **以分号结尾**，也可以不加分号，由解析器缺点语句的结尾
    
    ```jsx
    let sum = 5 // 未加分号
    let diff = 1; // 加了分号
    ```
    
    - 推荐使用分号
        - 有助于省略时造成不必要问题
        - 且有助于删除空行压缩代码
        - 可能提升性能（解析器会尝试在合适的位置加上分号以纠正语法错误）
- 多条语句可以合并到C语言风格的**代码块**中，即使用大括号（`{}`）包裹多条语句
    - 代码块通常出现在控制类语句中，如if，while等
        
        ```jsx
        if (flag) **{
        	flag = false;
        	console.log(flag);
        }**
        ```
        
    - 代码块也可以单独使用，作为一个局域使用，和C语言风格类似
        
        ```jsx
        let a = 1;
        **{
        	let a = 2;
        	console.log(a); // 2
        }**
        ```
        

# 2.关键字和保留字

- ECMA-262描述的一组保留的**关键字，**这些关键字有特殊用途
    - 表示控制语句的开始或结束
    - 循环语句的终止或继续
    - 声明常量或变量
    - 引入其他模块
    - ...
- ECMA-262第六版规定的ESMAScript6中所有关键字
    
    ```jsx
    break    do        in          typeof
    case     else      instanceof  var
    catch    export    new         void
    class    finally   super       with
    continue for       switch      yield
    debugger function  this
    default  if        throw
    delete   import    try
    ```
    
- ECMA-262第6版本也描述了**未来的保留字，**同样不能作为标识符或属性名
    - 它们在现在版本的语言中没有特定用途，但是保留给将来的关键字使用
    - 有些在ECMAScript7或者8版本里已经实现了
    - 全部保留字：
        
        ```jsx
        // 始终保留
        enum
        // 严格模式下保留
        implements package   public
        interface  protected static
        let        private
        // 模块代码中保留
        await
        ```
        
- 这些保留字和关键字**严格不能作为标识符，**但是可以**用作对象的属性名**
    - 虽然使用保留字或关键字做属性名不会报错，但是最好不要，以兼容过去和未来的ECMAScript版本
        
        ```jsx
        let a = {await:1, if:2};// 这样写不会报错，且可以正常读取
        ```
        
- 注意，在严格模式下， **eval和argments**不能作为变量名，否则会导致语法错误

# 3.变量

- ECMAScript的变量是松散型的，即变量可以保存任何类型的数据。
- 每个变量名只是一个用于保存任意值的命名占位符
- 声明变量或常量的关键字有三个：var, let, const
- var在任何版本的ECMAScript都可以使用，const和let只能在ECMAScript6版本及之后的版本使用

## 3.1 var关键字

- 定义
    - 描述：定义变量的关键字
    - 使用方式：使用var操作符，后跟变量名（即标识符）
        
        ```jsx
        var message;
        ```
        
        1. 整个语句声明了一个名为message的变量，它可以保存任意类型的值
        2. 不初始化的情况下，它的值为一个特殊值`undefined` 
        3. 可以同时声明后定义变量的值，也可声明后再起其他语句设置
        
        ```jsx
        var message = "hello";
        ```
        
        1. 上述是声明变量并赋值的语句，message变量被赋予一个字符串类型的值
        2. 这样的字符串值赋值**不会**标识该变量是一个字符串类型，仅仅是赋值，且后续可以随意设置为其他类型的值
        
        ```jsx
        var message = "hello";
        message = 100; // **合法变更值，但不推荐**
        ```
        
        1. 对于弱类型语言ECMAScript来说，这样做完全合法，但不推荐改变初始赋值时保存的值类型
        2. 其实现代的JavaScript经常这么做（反而更方便），如果要使用有类型检查的JavaScript，建议使用TypeScript(JavaScript的超集)
    - 如果需要定义多个变量
        - 可以每个变量起一个语句使用var声明定义
        - 也可以在**一条语句**中使用逗号分隔开每个变量（及可选的初始化）：
            
            ```jsx
            var message = "hi",
            		found,
            		age = 22;
            ```
            
            - 可以一次性声明并定义多个变量的原因在于，ECMAScript是松散类型的，可以使用不同数据类型进行初始化

### var声明作用域

- 使用var操作符定义的变量会成为包含它的函数的**局部变量**
    - 例如，使用var在一个函数中声明定义一个变量，函数执行退出后会被销毁
        
        ```jsx
        function test() {
        	var message = "hi"; // 局部变量
        }
        test(); //调用
        console.log(messsage); // 出错
        ```
        
        ⇒ 调用test函数使用var声明定义一个变量
        
        ⇒ 执行结束后变量被销毁，最后一行出错
        
- 在函数内部声明定义变量时省略var操作符，可以创建一个**全局变量**
    - 全局变量可以在函数被调用后的外部访问使用
        
        ```jsx
        function test() {
        	message = "hi"; // 全局变量
        }
        test(); // 调用
        console.log(message); // 打印出hi 
        ```
        
    - 不建议使用这种方式定义全局变量，在严格模式下被禁用，会抛出ReferenceError错误
        - 局部作用域中定义全局变量是一种迷惑行为
        - 这样定义的全局变量难以维护，因为其他人难以知道全局变量定义在了哪个局部作用域中

### var声明提升

- var关键字定义的变量有一个特性：**该变量会自动提升到作用域的顶部**
    
    ```jsx
    function foo() {
    	console.log(age);
    	var age = 22;
    }
    foo(); // 打印undefined;不会报错
    ```
    
    ⇒ 等价于
    
    ```jsx
    function foo() {
    	**var age;**
    	console.log(age);
    	age = 22;
    }
    foo(); // 打印undefined
    ```
    
    - ECMAScript运行时会被看作如上代码
    - 这就是所谓的提升（hoist）,即**把所有变量声明都拉到作用域的顶部**
- var关键字定义的变量还有一个特性就是：**重复声明**同一个变量不会出问题，相当于重复赋值
    
    ```jsx
    function foo() {
    	var age = 16;
    	var age = 26;
    	var age; // 无任何意义
    	console.log(age);
    }
    foo(); // 26
    ```
    

## 3.2 let声明

- let也是用来声明变量的关键字，但和var有很重要的区别，最重要区别在于
    - let声明的范围是**块作用域**
        - 即let声明的变量在任何作用域中都是局部变量
    - var声明的范围是**函数作用域**
        - var声明的变量只有在函数作用域中才是局部变量，且会具有声明提升效应
- 例子
    
    ```jsx
    if (true) {
    	var name = 'Matt';
    	let age = 22;
    	console.log(name); // Matt
    	console.log(age); // 26
    }
    console.log(name); // Matt
    **console.log(age); // RefferenceError： age没有定义**
    
    ```
    
    ⇒ let声明作用域仅限于块内部，**块作用域是函数作用域的子集**
    
    ⇒ var声明的作用域限制同样适用于let(即在函数中适用let声明的变量仍然是局部变量)
    

### let特性

- 不允许冗余声明：一个变量只能适用let声明一次，不允许使用let声明第二次
    
    ```jsx
    var name;
    var name; // 不会报错
    
    let age = 22;
    let age = 23; // SynataxError 标识符age已经声明过了
    ```
    
    - **混用**let和var声明冗余变量同样会报错，这不是因为声明不同类型，而是它们指出了变量在相关作用域的不同存在方式
        
        ```jsx
        var name;
        let name; //SynataxError
        
        let age;
        var age; //SynataxError
        ```
        
- J**avaScript引擎记录变量声明的标识符以及其所在的作用域**
    - 在**不同的作用域**中使用相同的标识符声明变量是可行的
    - 对于let在不同作用域声明的变量，它们不会相互影响
        
        ```jsx
        let age = 22;
        if (true) {
        	let age =26;
        	console.log(age); // 26 优先查找本作用域的标识符变量，没有再查找父作用域的
        }
        console.log(age); //22 处于父作用域中，不会查找子作用域的变量
        ```
        
    - 对于var在不同作用域中声明的变量
        - 如果是非函数作用域，由于状态提升，相当于重新赋值，会相互影响
        - 如果是在函数作用域，和let一样的效果
        
        ```jsx
        var name = "mangwu";
        
        if (true) {
        	var name = "wumang"; // 冗余声明，相当于赋值修改name
        	console.log(name); // "wumang"
        }
        
        function LogName() {
        	var name = "manwug"; // 局部变量
        	console.log(name);
        }
        LogName();
        console.log(name); // "wumang"
        ```
        

### let和var声明变量的其他区别

1. 暂时性死区
    
    let声明的变量不会在作用域中被提升
    
    var声明的变量在作用域中会被提升
    
    ```jsx
    // name会被提升
    console.log(name); //undefined
    var name = 'Matt';
    
    // age不会被提升
    console.log(age); // ReferenceError: age没有定义
    let age = 22; // 此行以上的所有代码区域称为**暂时性死区**
    ```
    
    - JavaScript引擎实际上会注意块后面的let声明，只是不能以任何方式引用未声明的变量
    - let声明之前的引用被称为“暂时性死区”（temporal dead zone）
2. 全局声明
    - 在浏览器环境下，使用let在全局作用域中声明的变量不会成为window对象的属性
        
        ```jsx
        var name = 'Matt';
        console.log(window.name); // 'Matt'
        
        let age = 22;
        console.log(window.age); // 'undefined'
        ```
        
    - 但是在全局声明的let变量在页面声明周期内存续，可以一直使用
    - 注意：在**node环境**下，var声明的变量不会挂载到node环境下的global对象上
        
        ```jsx
        // node环境性=下
        var name = 'mangwu';
        let age = 22;
        
        console.log(global.name); // undefined
        console.log(global.age); // undefined
        ```
        
3. 条件声明
    1. 对于var声明变量，JavaScript引擎会自动将多余的声明在作用域顶部合并为一个声明（var的[声明提升](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md)和[重复声明](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md)）
        
        所以对于var声明的变量，在不同的脚本块中，可以使用**条件声明**
        
        ```html
        <script>
        	var name = 'Nicholas';
        	let age = 26;
        </script>
        <script>
        	// 对于var声明的变量，如果没有声明就声明并赋值，这是一种**条件声明**
        	if (name === undefined) {
        		var name = 'mangwu';
        	}
        	console.log(name); // 前面声明了name，所以打印'Nicholas';
        	//即使不使用条件声明，也可以正常重新声明赋值，这是由于声明提升的原因
        	var name = "wumang";	
        
        	// 对于let声明的变量，在不同的脚本块中，也会检查之前是否声明了age
        	let age = 22; // 报错
        </script>
        ```
        
    2. 对于let变量，使用**条件声明**也不能解决，因为条件块中的**let声明的作用域仅限该块**
        
        所以在不同的脚本中使用条件声明对可能已被声明过的let变量是没有意义的
        
        ```html
        <script>
        	let name = "mangwu";
        	let age = 22;
        </script>
        <script>
        	// 假设脚本不确定页面中是否已经声明了同名变量
        	// 假设还未声明过，使用条件声明代码如下
        	if (typeof name === 'undefined') {
        		// 无效声明，因为let声明的变量是块作用域
        		let name;
        	}
        	// 这个赋值形同全局赋值
        	name = 'wumang'
        
        	// 使用try/catch语句
        	try {
        		console.log(age); // 如果没有声明过就会报错
        	} catch(error) {
        		// 在catch块中的声明是局部的
        		let age;
        	}
        	// 这个赋值形同全局赋值
        	age = 23;
        	</script>
        ```
        
        ⇒ 对此let作为ES6的新声明关键词，**不能依赖条件声明模式**
        
4. for循环中的let声明
    1. 对于var，for循环中的定义的**迭代变量**会渗透到循环体外部
        
        ```jsx
        for(var i = 0; i < 5; i++) {
        	var a = 2;
        	a++;
        	console.log(a);
        }
        console.log(i, a); //5 2
        ```
        
        - 在循环体中使用var声明定义的**迭代变量**循环完后不会销毁，占用空间和标识符
        - 循环体内使用var声明定义的变量在循环外仍然有用
        
        ⇒ 如果循环中有**异步**执行的语句，如异步打印迭代变量，最终会**打印退出循环时的迭代变量**
        
        ```jsx
        for(var i = 0; i < 5; i++) {
        	setTimeout(() => console.log(i), 0);
        }
        // 打印5 5 5 5 5
        ```
        
    2. 使用let声明迭代变量时不会出现上述情况
        - **循环体内的let声明的变量在每轮循环中都不是同一个变量**
        - let声明的迭代变量，JavaScript引擎在后台会**为每一个迭代循环声明一个新迭代变量，**所以异步语句引用的是不同的变量实例
        
        ```jsx
        for(let i = 0; i < 5; i++) {
        	setTimeout(() => console.log(i), 0);
        }
        // 打印0 1 2 3 4
        ```
        
        - for in / for of 循环也属于这种每轮声明一个独立变量实例的行为风格

## 3.3 const声明

- const 声明的行为和let基本相同
    - 块作用域
        
        ```jsx
        const name = "matt"
        if (true) {
        	const name = "mangwu"
        	console.log(name); 
        	// 先检查本作用域中是否存在该变量，再检查父作用域，打印 "mangwu"
        }
        // 块中name被销毁
        console.log(name); // "matt"
        ```
        
    - 局部常量
    - 没有声明提升
    - 不能冗余声明
        
        ```jsx
        // 重复声明会报错
        const name = "mangwu";
        const name = "wumang"; //SyntaxError
        ```
        
- const和let的唯一区别在于
    - const**声明变量的同时必须初始化变量**
    - 之后不能修改const声明的变量的值，否则导致错误
        
        ```jsx
        const age = 22;
        age = 36; // TypeError; 给常量赋值
        ```
        
    - 同时，这也**导致了**const声明不能用于声明循环中的**迭代变量**
        
        ```jsx
        for (const i = 0; i < 10; i++) {
        	// TypeError:给常量赋值
        }
        ```
        
        - 虽然每轮循环都会生成一个新的变量，当时i是自增的，不能用于迭代变量的声明
    - 但是，这一特性也就给了const新的应用，在**for/of和for-in**循环中特别有用
        
        ```jsx
        for (const value of [1, 2, 3]) {
        	console.log(value); //1, 2, 3
        }
        ```
        
        ```jsx
        for (const key in {a:1, b:2}) {
        	console.log(key);// a, b
        }
        ```
        
        ⇒ 每轮循环都会创建一个新的常量，即能使循环不渗透到循环体外，又能给循环的迭代量做出限制
        
- const声明的限制**只适用于指向的变量的引用**
    - 如果const声明的变量引用是一个对象，那么修改对象内部的属性并不违反const限制
        
        ```jsx
        const person = {
        	name: "mangwu"
        };
        person.name = 'wumang"; //不属于赋值修改
        person.age = 22; // const声明的person的引用没有改变
        
        person = {
        	age: 23
        }; // 错误，TypeError,不能再给常量赋值
        ```
        

## 3.4 声明变量的代码风格

- ES6的新声明变量的关键字进一步规范了JavaScript的书写，有助于提升代码质量
- ES6新增声明关键字的使用实践
    1. 不使用**var**
        1. var的函数作用域范围比let的块作用域大，会导致变量渗透
        2. 使用let和const能**明确作用域、声明位置、和值限制**
    2. const 优先，let次之
        1. 静态代码分析工具提前发现不合法赋值操作
        2. 优先使用const能让开发者更有信心推断某些变量的值不会改变

# 4.数据类型

- ECMAScript有**6种**简单数据类型（也称**原始类型**）
    - Undefined
    - Null
    - Boolean
    - Number
    - String
    - Symbol(ES6新增)
- ECMAScript有**一种**复杂数据类型
    - **Object（对象）**
- ES中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一表示
- ES的数据类型很灵活，一种数据类型可以当作多种数据类型来使用

## 4.1 判断数据类型的方式

- 使用**`typeof`**操作符可以确定任意变量的数据类型
    
    ```jsx
    // 假设 a是一个未知数据类型的变量
    typeof a; // 返回上述7中数据类型中的一种，使用字符串表示
    typeof(a); // typeof的另一种使用方式
    ```
    
- **`typeof` 特性**
    - 对于松散的ESMAScript的类型系统是很有用的
    - 它返回七种数据类型中的一种，使用字符串表示：
        1. “undefined” 表示变量值未定义
        2. “boolean” 表示值为布尔值
        3. “string” 表示值为字符串
        4. “number” 表示值为数值
        5. “obejct” 表示值为对象（而不是函数）**或null**
        6. “function” 表示值为函数
        7. “symbol” 表示值为符号
- **注意**
    - typeof是操作符，而**不是函数**
    - 对于null使用typeof会返回”object”,因为null被认为是一个空对象的引用
    - 严格来说，**函数也是一种对象，并不代表一种数据类型，但是函数有自己的特殊属性，所以有必要区分函数和其他对象**

## 4.2 Undefined类型

- Undefined类型的值只有一个，就是特殊值`undefined`
- 赋值方式：使用var或者let声明变量但是不赋初始值，相当于赋予了undefined值
    
    ```jsx
    let message;
    console.log(message == undefined); // true
    ```
    
    - message和字面量**`undefined`** 进行比较，二者相等
- 等同于
    
    ```jsx
    let messgae = undefined; // 非必要赋值
    console.log(message == undefined); //true
    ```
    
- 注意：
    1. 不要显示的给某个变量赋值undefined
    2. ECMA-262 第三版之前不存在undefined字面量
    3. undefined字面量的出现就是为了**正式明确空对象指针（null）和未初始化变量的区别**
    4. 未初始化变量（未赋值变量）和未定义变量是有区别的，前者指已使用let或者var进行了声明，后者则是未声明和赋值的未知标识符
    5. 未声明（定义）变量只能执行**一个有用操作**，即上一部分的typeof, 返回undefined
        
        ```jsx
        let name
        // let age
        
        typeof name; // 返回undefined
        typeof age; // 返回undefined
        ```
        
        - 二者使用typeof操作符都返回undefined（未定义），逻辑上是对的
        - 但是这两个变量有本质差别，一个是未定义（已声明未初始化）变量值，另一个是未定义（声明）变量
    6. undefined是一个**假值，**即可以在**条件语句**中使用它，假值还包括null，false，0等，在使用假值时一定要明确使用的是哪一个假值，如在条件语句中使用`undefined` 进行逻辑判断
        
         
        
        ```jsx
        let message;// undefined
        // let age
        
        if (message) {
        	// message不为假值时执行
        }
        
        if (!message) {
        	// 会被执行的语句块，此时message为undefined，语句块中条件为真
        }
        if (age) {} // 报错，age未定义
        
        ```
        

## 4.3 Null类型

- Null类型只有一个特殊值，null
    - 当时逻辑上，**null是一个空对象指针**
    - 所以使用typeof操作符确定变量类型时，null值变量会返回”object”
        
        ```jsx
        let person = null;
        typeof person; // object
        ```
        
- 应用
    - 在定义将来要保存的对象值的变量时，**使用null来初始化**
    - 同时null可以作为假值用于判断对象变量的值是否为空，从而进行其他操作
        
        ```jsx
        if (car !== null) {
        	// car不为空执行的代码
        } else {
        	// car为空执行的代码
        	car = vhicleInital(); // 可能会初始化赋值
        }
        ```
        

### null与undefined

- 二者是**派生关系**
    - **`undefiend`值是由`null`值派生出来的**
    - ECMA-262在**表面**上将其视为相等，但**本质**上不相等
        
        ```jsx
        console.log(undefined == null); // true
        ```
        
        ![undefined_null.png](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/undefined_null.png)
        
        - `==` 操作符在比较时会转换为它的操作数
- undefined值的产生和null有关系，但是用途完全不一样
    - `undefined`用于给未初始化值设定一个默认值，不推荐显示设置变量未**`undefined`**
        - 即该变量是什么类型，赋予什么值，还未确定，`undefined` 是它暂时的默认值
    - `null` 用于给**已确定为对象的变量，但是还未确定具体值的变量赋值**，一定会使用显示的赋值
        - 这样保证了null空对象指针的语义，且与undefined区分开来
- undefined与null的相同在于都是**假值，**null和undefined一样，在判断假值的时候，一定要明确自己想检查的值就是null这个字面量，而不仅仅是假值（因为假值有很多种）
    
    ```jsx
    let name = null;
    let age;
    if (name) {
    	// 不执行 
    }
    if (!name) {
    	// 执行
    }
    if (!age) {
    	// 执行
    }
    ```
    

## 4.4 Boolean类型

- 是ECMAScript使用最频繁的类型之一，有两个**字面量**
    - `**true**`
    - `**false**`
- 字面量特性
    1. `true`不是1,`false`也不是0
    2. 区分大小写，True和False等大小写混写形式是正常的标识符
- 其他的所有的ECMAScript类型的值**都有相应的布尔值等价形式**
    - 如1的布尔类型等价形式为`true` ,0的布尔类型等价形式为`false`
    - 转化方式：使用特定的`Boolean()`转化函数
        
        ```jsx
        let message = "Hello, world!";
        let messageAsBoolean = Boolean(message);  // true
        ```
        
    - 不同数据类型的值的布尔等价形式对照图
        
        
        | 数据类型 | 转化为true的值 | 转化为false的值 |
        | --- | --- | --- |
        | Boolean | true | false |
        | String | 非空字符串 | 空字符串("")  |
        | Number | 非零数值（包括无穷值） | 0，NaN |
        | Object | 任意对象（包括空数组） | null |
        | Undefined | N/A(不存在) | undefiend |
    - 在条件语句等控制流语句中会**自动执行其他类型到布尔值的转换**
        
        ```jsx
        let message = "Hello, World";
        if (message) {
        	// true 会执行
        	message = null;
        }
        if (message) {
        	// false 不会执行
        } 
        ```
        

## 4.5 Number类型

- ECMAScript中最有意思的数据类型
- Number类型使用IEEE754格式表示**整数**和**浮点值**（双精度值）

### 整数数字的数字格式

1. 十进制
    
    ```jsx
    let age = 22; // 十进制整数，直接写出来
    ```
    
2. 八进制：以0开始，八进制**在严格模式下无效，**会导致JavaScript引擎抛出错误
    
    ```jsx
    let octalNum = 070; // 八进制的56
    let octalNum2 = 067; // 八进制的55
    let octalNum3 = 078; // 无效的八进制，因为每位值大于等于8，视为78
    ```
    
    ⇒ 在ES6（ECMAScript 2015）中，严格模式下可以使用`0o` 前缀来表示8进制且不会报错
    
    ```jsx
    let octalNum = 0o123; // 进制的83
    ```
    
3. 十六进制，以0x开头（区分大小写），十六进制数字0~9、A~F(不区分大小写)
    
    ```jsx
    let hexNum1 = 0xA; // 十六进制，表示10
    let hexNum2 = 0x2f; // 十六进制，表示47
    ```
    
4. 二进制，以0b开头（区分大小写）
    
    ```jsx
    let binaryNum = 0b1011; // 二机制,表示11
    ```
    
- 注意：JavaScript的保存数值的方式存在正零(+0)和负零(-0),当在所有情况下都是等同的

### 浮点值

- 描述：
    - 包含小数点就可以构成浮点值，且小数点后面至少有一个数字
    - 存储浮点值的使用内存空间是存储整数值的两倍
1. 赋值浮点值方式
    
    ```jsx
    let floatNum = 0.1;
    let floatNum2 = .12; // 有效，但不推荐，表示0.12
    ```
    
2. 由于浮点值使用内存空间大，ECMAScript总是想方设法把值转化为整数
    1. 小数点后面没有数字时，或者是0时就会被当成整数处理
        
        ```jsx
        let floatNum1 = 10.; //当作整数10处理
        let floatNum2 = 1.0; // 当作整数1处理
        ```
        
    2. 当**使用的小数值是超过精度所能表示的数**时，对于循环小数乘以对应的数值可能产生整数
        
        ```jsx
        let floatNum = 0.6666666666666666; // 16位小数
        let newNum = floatNum * 3;
        console.log(newNum); // 2
        ```
        
        ![float.png](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/float.png)
        
3. 浮点数的**科学记数法：用于简洁表示很大或者很小的数**
    1. ECMAScript中的科学记数法格式是一个数值（整数或者浮点数）后面跟一个大写或者小写的字母e，再加上一个要乘以的10的多少幂次
        
        ```jsx
        let floatNum = 3.142e-2; // 表示0.003142
        let floatNum2 = 4.11e5; // 表示411000
        ```
        
    2. **默认**情况下ECMAScript会**将小数点后至少包含6个0的浮点值**转化为科学记数法
        
        ```jsx
        let floatNum = 0.0000000000000003;// 会自动转化为3e-17
        ```
        
4. 浮点数的精确度最高为17位小数，但在计算中不如整数精确，如0.1加0.2得到的不是0.3，而是0.300 000 000 000 000 04
    
    ```jsx
    let a = 0.1;
    let b = 0.2;
    //如果是 0.05和0.25则不会出现这种问题
    if ( a + b == 0.3) {// 逻辑上正确，但实际不通过，所以别这么使用
    	// 不会执行
    }
    ```
    
    ![IEEE754.png](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/IEEE754.png)
    
    注意：这种微小的舍入错误不是JavaScript独有的而是IEEE 754标准的问题，使用IEEE 754标准的其他语言同样会出现这种错误
    

### 值范围

- 内存限制，ECMAScript不会支持世界上所有的数字
- ECMAScript可表示的最小(正)数值保存在`Number.MIN_VALUE` 中，其值为5e-324
- ECMAScript可表示的最大数值保存在`Number.MAX_VALUE` 中，其值为1.797 693 134 862 315 7 e+308
- 所以**大概**ECMAScript能表示的值的访问为
    
    ```
    [-Number.MAX_VALUE, -Number.MIN_VALUE]
    0
    [Number.MIN_VALUE, Number.MAX_VALUE]
    ```
    
    ⇒ 其中**未考虑小数点后可表示精确度位数，**所以该范围仍然比能表示的范围大
    
- 超出-Number.MAX_VALUE和Number.MAX_VALUE的数会被自动转化为一个特殊的无穷值**`Infinity`**
    
    ```jsx
    let a = Number.MAX_VALUE * 2; // Infinity
    let b = -Number.MAX_VALUE / 0.5; // -Infinity
    ```
    
    - Infinity不能进一步进行计算
    - 可以使用isFinite()函数判断一个数值是否为可计算的值
        
        该函数对下面的NaN同样适用
        
        ```jsx
        let a = Number.MAX_VALUE * 2; // Infinity
        console.log(isFinite(a)); //false
        ```
        
    - 使用**Number.NEGATIVE_INFINITY**和**Number.POSITIVE_INFINITY**也可以取得正负Infinity

### NaN

- NaN表示不是一个数字，即Not a Number，用于表示数处理时操作失败了
    - 但它不是表示抛出错误
    - 而是计算过程中出现无法计算的情况时就会返回NaN，如0除以0
    
    ```jsx
    console.log(0 / 0); // NaN
    ```
    
    - 上面例子中如果分子不为0而是一个具体的数，会得到正或者负`Infinity`
- NaN有一些独特的特性：
    1. 任何涉及NaN操作的计算都会返回NaN
        
        ```jsx
        console.log(NaN * 5); // NaN
        ```
        
    2. NaN不等于包括NaN在内的任何值（Infinity不会出现这种情况，它会与符号相同的Infinity相等）
        
        ```jsx
        console.log(NaN == NaN); // false
        console.log(Infinity == Infinity); // true
        ```
        
    3. 需要有一个判断数值为NaN的函数，即isNaN()函数
        1. 该函数接受然后数据类型作为参数
        2. 该函数首先将参数值转化为数值类型
        3. 再判断该参数值是否“不是数值”（NaN）
        4. **任何不能转化为数值类型的参数值都会被认为不是数值**
        
        ```jsx
        console.log(isNaN(NaN)); // true
        console.log(isNaN(10)); // false
        console.log(isNaN(true)); // false true可以转化为数值1
        console.log(isNaN("true")); // true "true"是字符串，不能转化为数值
        console.log(isNaN("")); // false 空字符串可以转化为数值0
        ```
        
        ⇒ `isNaN()` 不常用，但是可以用于测试对象，其原理是
        
        1. 首先调用对象的valueOf()方法，确定该方法返回的值是否能转化为数值
        2. 再调用对象的toString()方法，再测试其返回值
        3. 上述是是ECMAScript内置函数和操作符的工作方式

### 数值转换

- ECMAScript中的数值类型只有一个即`Number`类型
- 弱类型语言同样需要将其它类型转化为数值的方法：
    1. `Number()` 转化函数，可用于任何数据类型，其规则如下
        1. 布尔值→数值类型，true → 1, false → 0
        2. 数值类型 直接返回
        3. null 类型 返回0
        4. 字符串类型
            1. 只包含数值字符和±号以及可选的一个有效小数点，转化为一个十进制数值
                
                ```jsx
                Number("-01.1"); // -1.1
                ```
                
            2. 字符是有效的十六进制格式，将转化该16进制格式为相应的十进制数值(不包括正负号和小数点)
                
                ```jsx
                Number("0x0123"); //291 
                ```
                
            3. 空字符串，返回0
            4. 不符合上述所有条件，返回NaN
        5. 对象类型
            1. 先调用对象的valueOf()方法，按照上述规则转化valueOf返回的值
            2. 如果转化结果为NaN，就调用toString()方法，按照字符串规则转化
                
                ```jsx
                const a = {b : 1};
                Number(a); //NaN
                ```
                
    2. `parseInt()`转化函数主要针对**字符串**类型
        1. 专注于字符串是否包含字符类型，字符前的空格会被忽略(但不会忽略中间的空格)
            
            ```jsx
            parseInt(' 23 '); // 23
            parseInt(' 2a3 '); // 2
            parseInt(' 2 3 '); // 2
            ```
            
        2. 原理：
            - **parseInt从第一个非空字符开始转换，如果第一个不是数字字符或者加减号,会立即返回NaN**
            - 当遍历到字符后，会以其为开头遍历连续的数值字符，直到遍历到的字符不是数值或者末尾，所以**只返回整数值**（不处理小数点）
            - 除此之外，它也能正常识别十六进制（谷歌浏览器环境下**默认不能**识别八进制和二机制），且默认以十进制形式返回
                
                ![16进制.png](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/16%E8%BF%9B%E5%88%B6.png)
                
        3. 参数：
            1. 参数1：必选，字符串
            2. 参数2：可选，用于指定底数（进制数）
            - 在指定进制数之后，就能根据进制数识别字符，而且可以省略特殊进制的前缀，如十六进制就可以省略前缀0x (但是其他进制仍然**不能**像之前[赋值](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md)一样使用添加前缀字符串)
                
                ```jsx
                let num1 = parseInt("AF", 16); // 175
                let num2 = parseInt("AF"); //NaN
                
                let num3 = parseInt("10", 2); // 2, 按照二进制解析，转化为10进制
                let num4 = parseInt("10", 8); // 8, 按照八进制解析
                ```
                
        
        ⇒ **建议使用paserInt时传入第二个参数，**即使只使用十进制，传入10即可
        
    3. `parseFloat()` 函数工作方式和`parseInt()`类似
        1. 从第一个非空字符开始转换，直到解析到无效的浮点数值字符
        2. 第一次出现的小数点会被成功转化，而第二个出现的小数点无效，剩余字符串被忽略
        3. 参数：
            1. 只有一个，即字符串，不能指定进制底数，只识别十进制数
            2. 所以该函数**不能识别**以0x开头的十六进制数（会被识别为0）
            3. 但是它对之前[所有浮点格式](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md)的字符串都能识别（包括科学记数法）
        - 尽量返回整数，有小数点就返回浮点数，不能识别就方法NaN
            
            ```jsx
            let num1 = parseFloat("1234blue"); // 1234 按照整数解析
            let num2 = parseFloat("0xA"); // 0 不识别十六进制数
            let num3 = parseFloat("  22.1.1"); // 22.1 第二个小数点无效
            let num4 = parseFloat("0213.12"); //213.12 自动忽略前面的0
            let num5 = parseFloat("1.34e-2"); // 0.0134 对科学计数法有效
            ```
            

## 4.6 String类型

- String即字符串类型，标识零个或多个16位Unicode字符序列，字符串可以使用三种符号包裹
    - 双引号 `"hello"`
    - 单引号`'Jobs'`
    - 反引号 ``Mangwu``
- 不同引号不会改变ECMAScript对字符串的解释方式（有些语言会改变）
- 引号必须是成对的，以某一种引号开头的字符必须以其结尾
- 在以一种引号包裹中的字符中可以使用其他引号
    
    ```jsx
    let phase = "He said: 'Hello!'."
    ```
    

### 字符字面量（转义字符）

- **字符字面量的一部分为转义字符**，用于表示非打印字符或者有其他用途的字符
    
    
    | 字面量 | 含义 |
    | --- | --- |
    | \n | 换行，表示newline,将当前位置移动到下一行的开头，也称LF符号 |
    | \t | （水平）制表，表示Horizontal tab,跳到下一个tab位置 |
    | \b | 退格，表示back， 将光标移回一格，它本身不删除任何字符，只是在它之后的字符会依次覆盖光标后的字符，在node环境中生效，在浏览器环境下不生效（测试显示谷歌和火狐都会被识别为未知字符） |
    | \r | 回车，表示Carriage Return，将当前位置移动到本行开头，也称CR符号。Windows系统下文本的行尾序列通常就是CRLF，表示回车换行 |
    | \f | 换页，表示Form feed/clear screen，将当前位置移动到下一页开头。一般只在打印（真打印）的时候有用，在node环境字符串打印中显示为一个空心未知字符 |
    | \\ | 反斜杠，用于转义的反斜杠自身表示时使用双反斜杠即可 |
    | \’ | 单引号，在以单引号标示的字符串中使用时，使用反斜杠表示该单引号非结尾 |
    | \” | 双引号，在以双引号标示的字符串中使用时，使用反斜杠表示该双引号非结尾 |
    | \` | 反引号，在以反引号标示的字符串中使用时，使用反斜杠表示该反引号非结尾 |
    | \xnn | 以十六进制编码nn表示的字符，例如‘a’的ASCII码为97，其十六进制为61，那么\x61就表示字符’a’ |
    | \nnn | 以八进制编码nnn表示的字符，例如’a’的ASCII码为97，其八进制为141，那么\141就表示字符’a’ |
    | \unnnn | 以十六进制编码nnnn表示的unicode字符，a字符的UTF-16码位为\u0061; 希腊字母Σ的unicode字符为\u03a3. |
- 转义字符特性
    1. 可以出现在字符串中的任意位置
        
        ```jsx
        let text = "Hello!\n\r This is a sigma: \"\u03a3\"";
        // Hello!
        // This is a sigma "Σ"
        ```
        
    2. 转义字符的长度被当作1，上面的sigma转义字符即使有6位，也当作一位看待
        - 因为转义序列表示一个字符
        - 字符串长度通过length属性获取
            
            ```jsx
            let sigma = '\u03a3';
            conbsole.log(sigma.length); //1
            ```
            
    3. 如果字符中包含**双字节字符，**那么length属性返回的值可能不是准确的字符数

### 字符串的特点

- **不可变性**（**immutable**）
    1. JavaScript中的字符串是不可变的，一旦创建值就不变了
    2. 要修改变量中的字符串值，必须销毁原先的字符串，然后使用包含新值的另一个字符串赋值到该变量
        
        ```jsx
        let lang = "Java";
        lang = lang + 'Script'; // 返回一个新字符串
        ```
        
        - lang先被分配4个字符空间容纳字符串”Java”
        - 然后被分配10个字符空间，填充上”Java”和”Script”
        - 最后原始的”Java”和”Script”被销毁（因为无用了）

### 字符串转换

- 将其他类型的值转化位字符串的方法有两种
    1. 一种是每种类型的值都内置的方法toString()
    2. 另一种是转型函数String()
- `toString()` 方法**被当前值调用并返回当前值的字符串等价值**
    - 例子
        
        ```jsx
        let age = 11;
        console.log(age.toString()); // 字符串"11";
        let flag = true;
        console.log(flag.toString()); // 字符串"true";
        console.log("Hello".toStirng()); // 返回自身的副本
        ```
        
    - 适用数据类型：
        - 数值
        - 布尔值
        - 对象
        - 字符串值
        - null和undefined值没有toString()方法
    - `toString()`对于大部分值都没有参数，除了数值
        - 参数x：接受一个进制底数，默认为10
        - 得到数值的x进制的字符串表示
            
            ```jsx
            let num = 10;
            console.log(num.toString(2)); // "1010" 10的二机制表示
            console.log(num.toString(8)); // "12" 10的八进制表示
            console.log(num.toString(16)); // 'a' 10的十六进制表示
            ```
            
- `String()` 函数
    - 但不确定变量值是否是null或者undefined时，使用String()转型函数
    - String函数适用于任何数据类型，它始终返回表示对应的字符串等价值
    - String函数的原理
        1. 值是有toString()方法的数据值，调用toString()并返回结果
        2. 值是null 返回”null”
        3. 值是undefined 返回“undefined”
        
        ```jsx
        let num = 10;
        let flag = true;
        let obj = null;
        let name;
        String(num); // '10'
        String(flag); // 'true'
        String(obj); // 'null'
        String(name); // 'undefined'
        ```
        
- 其他方式：使用＋符号将值加上空字符串也能转化为字符串
    
    ```jsx
    let num = 22;
    let age = num + ''; // '22'
    ```
    

### 模板字面量

- ECMAScript6新增的特性
- 模板字面量：
    - 描述：本质上就是**可以换行书写的字符串**，即不一定非使用\n，而可以在代码中**物理换行到达跨行定义字符串**的目的
    - 用法：使用反引号定义模板字符串
        
        ```jsx
        let multiLineString = `first string
        second string`;
        let multiLineString2 = "first string\nsecond string"; 
        console.log(multiLineString  === multiLineString2); // true
        ```
        
        ⇒ 使用模板字面量跨行定义的字符串和使用转义\n定义的一样
        
    - 应用：在定义模板时非常有用，如HTML模板
        
        ```jsx
        let pageHtml = `
        <div>
        	<a href="#">
        		link
        	</a>
        <div>
        `
        ```
        
    - 注意：
        - 模板字面量会保持反引号内部的空格和换行，使用时格外注意
        - 在换行时注意缩放得当
            
            ```jsx
            let error = `bad
            						 template`; // 这个字符串前有很多空格符
            let error = `
            first line
            second line
            `; // 这个字符串实际上以一个换行符开头，文本段不是第一行
            ```
            
    - ES6之前想要**代码物理换行**需要使用`\` 符号，但其实这是一个bug
        
        ```jsx
        let str = "first line\n\
        second line"；
        console.log(str);
        // first line
        // second line
        
        ```
        
        ⇒ 注意反斜杠可以承接下一行代码，不属于字符串
        
        ⇒ 模板字面量[产生原因](https://www.cnblogs.com/xiaohuochai/p/7234281.html) 就是为了方便创造多行字符串
        

### 字符串插值

- 字符串插值就是**在字符串中插入变量**，这一特性由模板字符串支持
- 本质上模板字符串不是字符串，而是**一种特殊的JavaScript句法表达式**，求值后得到字符串
- 模板字面量在定义时立即对包裹在反引号中的字符和变量求值然后转化为字符串实例
    - 插值变量从最近的作用域中取值
    - 字符串插值使用`${var}` 的形式实现，var为一个变量
    - 字符串插值会被强制使用`toString()` 转化为字符串
    - 字符串插值在一定程度上简化字符串构造，不必使用麻烦的＋号和断续的字符串相加
- 一个使用模板字面量进行字符串插值的例子：
    
    ```jsx
    let age = 22;
    const sports = ['skating', 'football', 'tableball'];
    let interpolatedString = `I'm **${age}**, I like **${sports.join(',')}**.`;
    ```
    
    - 在`${}` 中可以插入任何的JavaScript表达式
- 功能强大的字符串插值：
    1. 插值会被强制调用toString，可以在对象中自定义toString方法
        
        ```jsx
        let foo = {
        	name: "Hello",
        	age: 2022,
        	toString: () => `${foo.name} ${foo.age}`,
        }
        const sayHi = `I want to say ${foo}`; //'I want to say Hello 2022'
        ```
        
    2. 插值可以嵌套使用（上面自定义的toString()中返回的模板字面量也是使用了插值）
        
        ```jsx
        let age = 22;
        let good = "You are adult";
        let bad = "You are nonage!"
        let nestString = `We must ask you:${age >= 18 ? `Ok,${good}` : `Sorry,${bad}`}`; 
        ```
        
    3. 插值表达式可以调用函数和方法
        
        ```jsx
        function capitalize(word) {
        	return `${word[0].toLocaleUpperCase()}${word.slice(1)}`;
        }
        console.log(`${capitalize("hello")}, ${capitalize("world!")}`); //Hello, World
        ```
        
    4. **模板可以插入之前的值，即将字符串本身作为插值插入，插入的是未被赋值前的值**
        
        ```jsx
        let value = '';
        function append() {
        	value = `${value}abc`;
        	console.log(value);
        }
        append(); //abc
        append(); //abcabc
        append(); //abcabcabc
        ```
        

### 模板字面量标签函数

- 模板字面量支持定义**标签函数**（tag function）
- **标签函数**
    - 本质是一个普通的函数可以通过括号加参数正常调用
    - 除此之外，还可以通过反引号的形式进行调用即`tagFunc`templateStr``
    - 通过反引号调用的参数传递方式为：
        - 第一个参数为**由字符串插值分割的字符串数组**
        - 后面的每个参数是每个字符串插值的结果（还未转化为字符串的表达式结果）
    - 标签函数可以自定义返回值（一般处理参数后获得返回值结果）
- 例子
    
    ```jsx
    // 标签函数：模板字面量支持的函数
    
    function tagFunc(strings, ...expressions) {
      console.log(strings);
      for (const expression of expressions) {
        console.log(expression,typeof expression);
      }
      return "处理后的模板字面量";
    }
    
    let a = 1;
    let b = 2;
    let str = `${a} + ${b} = ${a + b}`;
    tagFunc`${a} + ${b} = ${a + b}`;
    
    // [ '', ' + ', ' = ', '' ]
    // 1 number
    // 2 number
    // 3 number
    ```
    
    ⇒ 注意：
    
    - 字符串插值分割的模板字符串数组中包括了**左右边界两个空字符串**
    - 通过**剩余操作符（rest operator）**将剩余的参数收集到一个数组中，方便对字符串插值未知的模板字面量进行处理
    - 如果模板字面量有**n个插值，**那么由插值分割的原始字符串数组一定是**n+1**的长度

### 原始字符串

- 模板字面量的特性
    - 可以通过`String.raw`获取**原始的模板字面量内容**
    - 原始的内容指：未对转义字面量进行转换的字符表示
- 注意: String.raw是标签函数，不能通过括号调用
- 调用`String.raw`时直接在后面接上模板字面量就可以返回它的原始字符串形式
    - 返回\u00A9的原始字符（\u00A9是©的转义字符）
        
        ```jsx
        console.log("\u00A9"); // ©
        console.log(String.raw`\u00A9`); // \u00A9
        ```
        
    - 返回\n的原始字符（即不显示换行）
        
        ```jsx
        console.log("first line\nsecond line"); 
        // first line
        // second line
        console.log(String.raw(`first line\nsecond line`));
        // first line\nsecond line
        ```
        
    - **注意：模板字面量物理换行后的转义\n不会被转化出来**
        
        ```jsx
        console.log(String.raw(`first line
        second line`));
        // first line
        // second line
        ```
        
- 除了String中的raw标签函数可以获得原始字符串外，还可以通过标签函数中的[第一个参数](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md) **字符串数组的raw属性获得每个被分割的字符串的原始字符串**
    
    ```jsx
    // raw属性
    const tagFunc = (strings) => {
      console.log("----实际字符串----");
      for(const str of strings) {
        console.log(str);
      }
      console.log("----原始字符串----");
      for(const str of strings.raw) {
        console.log(str);
      }
    }
    let chazhi = 1;
    tagFunc`\u00A9${chazhi}\n`
    // ----实际字符串----
    // ©
    // (换行符)
    
    // ----原始字符串----
    // \u00A9
    // \n
    ```
    

## 4.7 Symbol类型

- Symbol（符号）是ECMAScript6新增的数据类型
- 描述：
    - 符号是原始值，且**符号实例唯一、不可变的**
    - 用途：确保**对象属性使用唯一标识符**，不会发生属性冲突的危险
    - Object API提供了方法，可以更方便的发现符号属性
    - 符号不是为了提供私有属性而添加的，相反，它就是用来创建唯一记号，进而**用作非字符串形式的对象属性**

### 符号的基本用法

- 用法：
    - 使用Symbol函数初始化
        
        ```jsx
        let sym = Symbol();
        ```
        
        ⇒ 注意Symbol函数不是一个构造函数（即**不能用new关键字**）
        
    - 原始类型的符号实例使用typeof返回 symbol
        
        ```jsx
        console.log(typeof sym); // symbol
        ```
        
    - 调用Symbol函数可以传递字符串或者数字作为对符号的描述（description）
        
        ```jsx
        let fooSymbol = Symbol('foo');
        let otherFooSymbol = Symbol("foo");
        
        console.log(fooSymbol == otherFooSymbol); //false
        console.log(fooSymbol); //Symbol(foo) (打印调试区分)
        ```
        
        ⇒ 注意，描述仅用于代码调试，**这种描述本身与符号定义和标识完全无关**
        
    - **符号没有字面量语法**，这是它发挥作用的关键，因为这保证了它完全可以作为对象的新属性，且**保证它不会覆盖已有的对象属性，无论是对象中已经存在的符号属性还是字符串属性**
        
        ```jsx
        // 当作新属性，不会覆盖已有属性
        
        const a = {
          foo: "oldFoo",
          "foo": "newFoo",
        };
        
        a[foosym] = "oldFoo";
        a[foosym] = "newFoo";
        a[otherfoosym] = "newFoo";
        console.log(a);
        // { foo: 'newFoo', [Symbol(foo)]: 'newFoo', [Symbol(foo)]: 'newFoo' }
        ```
        
        ⇒ 可以看到，字符串属性会覆盖已有的属性
        
        ⇒ 每个**不同的符号都会保证不覆盖已有的对象属性**
        
    - Symbol函数设定不与new关键字一起作为构造函数使用的原因
        1. **避免创建符号包装对象**
        2. Boolean，String等都支持构造函数且可以用于初始化包含原始值的**包装对象**，它们的字面量可以相等
        3. 为了保证没有字面量且每个符号都不相等，不能通过另一个符号构建新的符号就是基本要求
            
            ```jsx
            let str = new String("string");
            console.log(typeof str); // Object 包装对象
            
            let sym = new Symbol(); // TypeError
            ```
            
            ![Untitled](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Untitled.png)
            
    - 如果想使用符号包装，可以借用Object()函数
        
        ```jsx
        let mySym = Symbol();
        let myWrapper = Object(mySym);
        typeof(myWrapper);
        ```
        
        ![Untitled](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Untitled%201.png)
        
        ⇒ 当这本质上就是新建一个对象，包含一个属性值Symbol()符号，和可能存在的description属性和描述值
        

### 使用全局符号注册表

- 符号的全局注册表指：
    - 一个以字符串为键，键值为唯一个符号的全局表
    - 通过全局符号注册表创建符号时，先会检查该键在符号表上是否已创建过符号，如果创建过就返回**相同的符号，**否则新建一个符号，并记录在全局符号注册表中
    - 全局符号注册表可以使**不同的部分共享和重用符号实例**
- 使用方式：
    - 通过`Symbol.for()` 方法注册全局符号
        
        ```jsx
        let globalSym = Symbol.for("foo");
        console.log(typeof globalSym);
        ```
        
    - 重用已有符号时，返回得到的符号和原始符号幂等
        
        ```jsx
        let globalSym = Symbol.for('foo');
        let otherGlobalSym = Symbol.for('foo');
        
        console.log(globalSym ===otherGlobalSym); // true
        ```
        
        ⇒ 全局符号的每个字符串键对应同一个全局符号
        
        ⇒ 全局符号注册表中不存在当前字符串键的符号就会新建并记录
        
    - 全局符号和和采用相同描述的局部符号不等同，它们属于两个不同符号
        
        ```jsx
        // 描述符号相同的局部符号是个新符号和全局符号不相等
        const localSym = Symbol("foo");
        console.log(globalSym === localSym);
        ```
        
    - 全局符号的键必须由字符串创建，任何传入`Symbol.for()` 中的值都会被转化为字符串，键也被作为符号描述
        
        ```jsx
        // 键值必须时字符串，仍然参数都会被转化为字符串
        const globalSym2 = Symbol.for(); // 相当于undefined
        const globalSym3 = Symbol.for(null); // 转化为"null"
        const globalSym4 = Symbol.for([]); // 空字符串
        console.log(globalSym2, globalSym3, globalSym4);
        // Symbol(undefined) Symbol(null) Symbol()
        ```
        
- 查询全局符号
    - 通过`Symbol.keyFor()` 方法查询全局注册表，这个方法**接受符号**，返回该全局符号对应的字符串键
    - 查询的是局部符号，返回undefined
    - 查询的不是符号，抛出TypeError错误
        
        ```jsx
        // 查询符号的键,只对全局符号有效
        console.log(Symbol.keyFor(globalSym3)); // null 
        console.log(Symbol.keyFor(localSym)); // undefined
        try {
          console.log(Symbol.keyFor("foo")); // 报错
        } catch (error) {
          console.log("查询的不是符号", error);
        }
        ```
        

### 使用符号作为属性

- 凡是可以用字符串或数值做为属性的地方，都可以使用符号
- 所以在**对象字面量属性**和**`Object.defineProperty()/Object.defineProperties()`**定义属性时可以使用符号定义
- 使用符号通过**对象字面量**方式定义属性的方式
    - 对象字面量只能在**计算属性语法**中使用符号作为属性
    - 计算属性语法如下
        
        ```jsx
        // 计算属性语法
        let a = 1;
        let c = 2;
        const obj = {
          **[a]: 2, // 计算属性语法**
          a: 3,
        };
        **obj[c] = 2; // 另一种计算属性语法**
        **console.log(obj); // {'1':2, '2'： 2,a: 3}**
        ```
        
    - 所以使用符号定义对象属性时，也需要使用计算属性语法，不能直接通过字面量定义
        
        ```jsx
        // 符号属性需要使用计算属性语法
        const sym = Symbol("foo");
        const sym2 = Symbol("foo");
        const obj2 = {
          [sym]: "foo",
        };
        obj2[sym2] = "foo";
        console.log(obj2);
        // { [Symbol(foo)]: 'foo', [Symbol(foo)]: 'foo' }
        ```
        
- 使用对象定义属性的方法定义对象的属性为符号
    - Object.defineProperty(obj, prop, descriptor)
        - 参数1， obj，被定义的属性的对象
        - 参数2，prop，属性名称（一般为字面量，也可以是变量），可以是符号
        - 参数3，属性描述符，对象类型，一般包括属性值（value），属性是否可写（writable），查看**[Object.defineProperty_MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)**
            
            ```jsx
            const object1 = {};
            
            Object.defineProperty(object1, 'property1', {
              value: 42,
              writable: false
            });
            
            object1.property1 = 77;
            // throws an error in **strict mode**
            
            console.log(object1.property1);
            // expected output: 42
            ```
            
        - 定义符号属性
            
            ```jsx
            // 通过对象定义属性方法定义符号属性
            let o = {};
            Object.defineProperty(o, sym, { value: "sym's value" });
            console.log(o, o[sym]);
            // {} sym's value
            Object.defineProperty(obj2, sym, { value: "sym's value" });
            console.log(obj2);
            // { [Symbol(foo)]: "sym's value", [Symbol(foo)]: 'foo' }
            ```
            
            ⇒ 注意，通过{}新建的对象o，在定义符号属性后，**node环境(v16.14.0)**下打印出来的属性和值为空，而**实际上它是有sym符号属性**的
            
            ⇒ 而之前obj2使用对象字面量方式定义过sym符号属性的再次修改属性值可以成功且能打印出来
            
            ⇒ 浏览器环境（谷歌）可以打印出来
            
            ![Untitled](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Untitled%202.png)
            
    - Object.defineProperties(obj, props)
        - 参数1 obj ，被定义属性的对象
        - 参数2 props，对象类型，要定义的可枚举的属性或修改属性描述符的对象，形如`{[prop1]: {value: "hello"}, [prop2]: {value: "world"}}` ;其中prop1和prop2如果是字面量，可以不使用计算属性语法定义
        - 查看**[MDN_Object.defineProperties](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)**
        - 定义符号属性（需要使用计算属性语法）
            
            ```jsx
            // 定义多个
            let obj3 = {};
            Object.defineProperties(obj3, {
              [sym]: {
                value: "Hello",
              },
              [sym2]: {
                value: "world",
              },
            });
            console.log(obj3, obj3[sym2]); //{} world
            ```
            
            ⇒ 注意，同样在node(v16.14.0)环境中新建符号属性时打印不出来，但是实际有值
            
            ⇒ 在浏览器环境(谷歌)可以打印出来
            
            ![Untitled](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Untitled%203.png)
            
- **获取对象属性**
    - `Object.getOwnPropertyNames()`返回对象实例中的**常规属性数组**
    - `Object.getOwnPropertySymbols()`返回对象实例中的**符号属性数组** 二者的返回值彼此互补
    - `Object.getOwnPropertyDescriptors()` 返回对象实例中**包含常规和符号属性的描述符**的对象
    - `Reflect.ownKeys()`会返回两种类型的键，它的值等同于`Object.getOwnPropertySymbols().concat(Object.getOwnPropertyNames())`
        
        ```jsx
        // 获取对象属性键
        obj[sym] = "Hello";
        console.log(Object.getOwnPropertyNames(obj));
        console.log(Object.getOwnPropertySymbols(obj));
        console.log(Reflect.ownKeys(obj));
        console.log(Object.getOwnPropertyDescriptors(obj));
        // 打印结果
        [ '1', '2', 'a' ]
        [ Symbol(foo) ]
        [ '1', '2', 'a', Symbol(foo) ]
        {
          '1': { value: 2, writable: true, enumerable: true, configurable: true },
          '2': { value: 2, writable: true, enumerable: true, configurable: true },
          a: { value: 3, writable: true, enumerable: true, configurable: true },
          [Symbol(foo)]: {
            value: 'Hello',
            writable: true,
            enumerable: true,
            configurable: true
          }
        }
        ```
        
- 如果通过计算属性语法**直接在`[]`中新创建符号作为属性**，它们是不会丢失的；但是如果没有使用变量保存这些符号，就需要遍历整个对象中的符号属性才能找到相应的属性键
    
    ```jsx
    // 寻找未显示保存在变量中的符号属性
    
    let obj4 = {
      [Symbol("foo")]: "symfoo",
      [Symbol("bar")]: "symbar",
    };
    let symbar = Object.getOwnPropertySymbols(obj4).find((sym) =>
      sym.toString().match(/bar/)
    );
    console.log(symbar);
    ```
    

### 常用内置符号

- ES6引入了一些**常用的内置符号**（well-known symbol）,用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为
- 这些内置符号**以Symbol工厂函数字符串属性的形式存在**
- 这些内置符号最重要的作用就是**作为对象属性被重新定义**，改变对象的原生结构行为
    - 例如，使用for of遍历数组对象，会使用Symbol.iterator属性
    - 普通对象上的并未定义迭代器符号属性，可以通过定义一个迭代器属性，来改变for of 在迭代该对象时的行为
        
        ```jsx
        
        // 用于对象属性被重新定义，改变对象的原生结构
        
        const a = {
          b: 2,
        };
        // for in可以遍历对象的属性（不包括符号属性）
        for (let key in a) {
          console.log(key); //b
        }
        // for of却不可以，但是通过定义对象的迭代符号属性就可以使用for of遍历了
        **a[Symbol.iterator] = function* () {
          yield 1;
          yield 2;
          yield 3;
        };**
        for (let v of a) {
          console.log(v);// 1 2 3
        }
        ```
        
- 常用内置符号与普通符号没有特别之处，它们就是全局函数Symbol的普通字符串属性，指向一个符号实例
    - 所有内置符号属性都是不可写、不可枚举、不可配置的
    - 注意，ES规范会引用符号在规范中的名称，前缀为`@@` ，如`Symbol.iterator` 按照规范也可以写成`@@iterator` （代码中会提示错误，规范中用以表示内置符号属性）

下面是一些常用内置符号

---

### 常用内置符号

[常用内置符号](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7.md)

## 4.8 Object类型

- 是ECMAScript规范中的唯一一个复杂数据类型，区分于原始数据类型

### 描述

- ECMAScript中的对象其实就是**一组数据和功能的集合**

### 语法

- 创建对象通过new 操作符号后跟对象类型的名称来创建
    
    ```jsx
    let o = new Object();
    ```
    
- 这个语法类似Java，但是ECMAScript只要求在需要给构造函数参数时使用括号，没有参数，可以省略括号，如下（但不推荐这么做）
    
    ```jsx
    let o = new Object; // 合法创建对象
    ```
    
- 除此之外，还可以通过**字面量创建Object对象**
    
    ```jsx
    var obj = {};
    ```
    
    - 花括号包含具体对象的属性和方法

### 功能

- Object实例本身不是很有用，但是其概念和抽象的思想非常重要
- ECMAScript中的Obejct类似于Java中的`java.lang.Object`
- Object类也是派生其它对象的基类，其它对象默认继承Object中已有的属性和方法
- 每个Object实例对象有如下属性和方法
    - `constructor`:用于创建当前对象的函数，对于Object，其属性值就是Object()函数
        
        > “**constructor**”属性返回`Object` 的构造函数，此属性的值就是对函数本身的引用，而不是一个包含函数名称的字符串
        > 
        
        ```jsx
        // 对象constructor属性返回对象的构造方法，它就是对构造函数本身的引用
        
        const o = {};
        console.log(o.constructor, o.constructor == Object, Object);
        
        const a = [];
        console.log(a.constructor, a.constructor == Array, Array);
        
        const n = Number(3);
        console.log(n.constructor, n.constructor == Number, Number);
        // 打印
        [Function: Object] true [Function: Object]
        [Function: Array] true [Function: Array]
        [Function: Number] true [Function: Number]
        ```
        
    
    - `hasOwnProperty(propertyName:string)`: 判断当前对象实例上是否存在给定的属性，被检查的属性名必须是字符串或者符号
        
        > 所有继承了Object的类都会继承hasOwnProperty方法，该方法**会忽略那些从原型链上继承到的属性**
        > 
        - 即，hasOwnProperty方法只对**对象自定义的属性判断有效**，使用o.valueOf()方法可以默认看到用户定义的属性
        
        ```jsx
        // hasOwnProperty只检查自定义属性，不检查来自原型链上的属性
        const o = {
          [Symbol.isConcatSpreadable]: true,
          length: 2,
          0: "property1",
          1: "property2",
        };
        console.log(o.hasOwnProperty(Symbol.isConcatSpreadable)); // true
        console.log(o.hasOwnProperty(0)); // true
        console.log(o.hasOwnProperty(Symbol.iterator)); // false
        console.log(o.hasOwnProperty("toString")); // false
        console.log(o.hasOwnProperty("hasOwnProperty")); // false
        
        // 打印 
        true
        true
        false 
        false // 不检查原型链上的属性
        false
        ```
        
        - 和`in`操作符不同，`in`操作符会读取到继承的可枚举属性
            
            > **`for...in`语句**以任意顺序迭代一个对象的除[Symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)以外的[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)属性，包括继承的可枚举属性。
            > 
        
        ```jsx
        class O {
          constructor(len, arr) {
            this.length = len;
            for (let i = 0; i < len; i++) {
              this[i] = arr[i];
            }
            this.odata = "odata";
          }
          [Symbol.isConcatSpreadable] = true;
        }
        const o = new O(2, [1, 2]);
        // 原型链上的属性
        O.prototype.toOdata = () => {
          return this.odata.toString();
        };
        // in操作符
        for (const name in o) {
          if (o.hasOwnProperty(name)) {
            console.log("own property:", name, o[name]);
          } else {
            console.log("prototype property:", name, o[name]);
          }
        }
        // 
        own property: 0 1
        own property: 1 2
        own property: length 2
        own property: odata odata
        prototype property: toOdata [Function (anonymous)]
        ```
        
        ⇒ for in遍历了原型链上的属性和继承的可枚举的属性
        
    - `isPrototypeOf(object)` :用于判断当前对象(调用对象)是否为另一个对象的原型
        
        
        > 备注：isPrototypeOf与instanceOf运算符不同，在表达式”object instanceOf AFucntion”中，object'的原型链是针对AFunction.prototype进行检查的，而不是AFunction本身
        > 
        - 使用方式
            
            ```jsx
            prototypeObj.isPrototypeOf(object);
            ```
            
        - 检查prototypeObj(对象类)是否在object对象的原型链上
            
            ```jsx
            // 检查类是否在对象上的原型链上（实际上就是检查类是否是该对象的类或父类）
            
            class A {}
            function B() {}
            function C() {}
            
            // 连接原型链
            B.prototype = Object.create(A.prototype);
            C.prototype = Object.create(B.prototype);
            
            const c = new C();
            console.log(C.prototype.isPrototypeOf(c));
            console.log(B.prototype.isPrototypeOf(c));
            console.log(A.prototype.isPrototypeOf(c));
            console.log(Object.prototype.isPrototypeOf(c));
            
            // 打印
            true
            true
            true
            true
            ```
            
    - `propertyIsEnumerable(propertyName)` :用于判断给定的属性是否可以使用for-in语句枚举（即属性是可枚举的属性），属性名必须是字符串
        - 通常由对象调用，表示指定的属性是否可枚举
        - 常见的例子就是数组对象，数组对象中的每个索引属性都是可枚举的，但是length属性不可枚举
            
            ```jsx
            // propertyIsEnumerable有对象调用，表明指定的属性是否可枚举
            const a = [1, 2, 3];
            console.log(a.propertyIsEnumerable(0));
            console.log(a.propertyIsEnumerable(1));
            console.log(a.propertyIsEnumerable(2));
            console.log(a.propertyIsEnumerable("length"));
            // 打印
            true
            true
            true
            false // length不可枚举 所以返回false
            ```
            
    - `toLocaleString()` 返回对象的字符串表示，该字符串反映对象所在的本地化执行环境
        - 由对象调用，通常每个内置对象都会对toLocaleString()进行覆写（默认返回`[object Object]`）
        - 例如**数字对象**中的toLocaleString()就会返回美式的数字格式，三位一个逗号，精确三位小数点
        - 例如**时期对象**中的toLocaleString()就会根据时区返回相应的时间日期
            
            ```jsx
            // 数字对象
            const a = 123456.7891;
            console.log(a.toLocaleString());
            
            // 时期
            const date = new Date();
            console.log(date.toLocaleString());
            
            // 打印
            123,456.789 // 三位一个逗号，精确三位
            2022/5/23 21:58:32 // 北京时间
            ```
            
    - `toString()` 返回对象的字符串表示，可以查看[Symbol.toPrimitive]中[关于对象转化为原始类型的toString()方式](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7/%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84Object%E6%96%B9%E6%B3%95.md)
    - `valueOf()` 返回对象对应的字符串，数字或者布尔值表示，可查看[关于对象转为原始类型的valueOf()方式](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E7%AC%A6%E5%8F%B7/%E5%AF%B9%E8%B1%A1%E8%BD%AC%E5%8E%9F%E5%A7%8B%E5%80%BC%E7%9A%84Object%E6%96%B9%E6%B3%95.md)

### 注意

- 严格来说，Object只是ECMAScript定义的所有对象的**基类，**而不一定适合于JavaScript中的其他对象
- 这里JavaScript指在不同的宿主环境下的ECMAScript实现，例如浏览器环境，Nodejs环境
- 浏览环境下的BOM和DOM对象由宿主环境定义和提供，宿主对象不受ECMA-262约束，所以有些对象不一定会继承Object

---

# 5.操作符

- ECMAScript规范定义了一系列在其它语言中同样需要定义的**操作符**
- 这些操作符可用于操作数据值，包括**数学操作符、位操作符、关系操作符、和相等操作符**
- ECMAScript的操作符与其它语言的不同之处在于：
    
    > ECMAScript中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值、甚至还有对象
    > 
- 在应用给对象时，通常会调用对象的valueOf()或toString()方法

## 5.1 一元操作符与位操作符

[5.1一元操作符与位操作符](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5%201%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6.md)

## 5.2 布尔操作符

[5.2布尔操作符](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5%202%E5%B8%83%E5%B0%94%E6%93%8D%E4%BD%9C%E7%AC%A6.md)

## 5.3 乘性操作符

[5.3乘性操作符](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5%203%E4%B9%98%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6.md)

## 5.4 指数操作符

[5.4指数操作符](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5%204%E6%8C%87%E6%95%B0%E6%93%8D%E4%BD%9C%E7%AC%A6.md)

## 5.5 加性操作符

[5.5加性操作符](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5%205%E5%8A%A0%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6.md)

## 5.6 关系操作符

[5.6 关系操作符](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5%206%20%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6.md)

## 5.7 相等操作符

[5.7 相等操作符](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5%207%20%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6.md)

## 5.8 条件操作符

[条件操作符](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%9D%A1%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%AC%A6.md)

## 5.9 赋值操作符

[5.9 赋值操作符](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5%209%20%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E7%AC%A6.md)

## 5.10 逗号操作符

[5.10 逗号操作符](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/5%2010%20%E9%80%97%E5%8F%B7%E6%93%8D%E4%BD%9C%E7%AC%A6.md)

# 6. 语句

ECMAScript中的语句体现了其大部分的语法，语句又称为**流控制语句**，它们可以简单也可复杂，是一条条需要被执行的指令

## 6.1 条件语句

[6.1.1 条件语句（if语句）](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/6%201%201%20%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5%EF%BC%88if%E8%AF%AD%E5%8F%A5%EF%BC%89.md)

[6.1.2 switch语句](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/6%201%202%20switch%E8%AF%AD%E5%8F%A5.md)

## 6.2 循环语句

[6.2.1while语句](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/6%202%201while%E8%AF%AD%E5%8F%A5.md)

[6.2.2 for语句](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/6%202%202%20for%E8%AF%AD%E5%8F%A5.md)

## 6.3 循环控制语句

[6.3.1 break和continue语句](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/6%203%201%20break%E5%92%8Ccontinue%E8%AF%AD%E5%8F%A5.md)

[6.3.2 标签语句](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/6%203%202%20%E6%A0%87%E7%AD%BE%E8%AF%AD%E5%8F%A5.md)

## 6.4 with

[6.4 with语句](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/6%204%20with%E8%AF%AD%E5%8F%A5.md)

# 7. 函数

函数在任何语言中都是核心，因为函数具有**封装**的属性，它封装了语句块，只要调用函数就能执行封装在其中的语句块，不用重新书写相关语句块，这极大的提高了代码的编写效率

## 语法

### 函数声明

```jsx
function functionName(arg0, arg1, ... argN) {
	statements
}
```

- 使用function关键字声明函数
- 函数名一般是小驼峰，且在作用域中是独一的
- 函数名后跟括号，括号中是需要的参数，参数可以为空
- 最后使用大括号({})书写函数的函数体

### 函数调用

- 一般情况下，使用函数名加括号，括号中传入函数需要的参数进行调用

```jsx
functionName(args);
```

⇒ 还可以通过apply和call函数进行调用

## 函数的返回值

- ECMAScript中的函数**不一定有返回值**
- 如果有返回值，**只能使用return语句**进行返回
    - **return语句被执行，函数就会立即停止执行并退出**
    - 一个函数里可以有多个return语句，配合条件语句使用
    - **没有return语句**或者**return不带返回值**的函数执行完毕后返回undefined
    - 可以使用`return;` (不返回任何值)，立即终止函数执行

## 使用注意

1. **函数要么始终返回值，要么始终不返回值**，否则可能因为条件一会有值返回，一会没有值返回会照成麻烦
2. 函数不能以eval或arguments作为名称
3. 函数的参数不能叫eval或arguments

## 例子

```jsx
// 使用function定义的代码块，可以复用，具有封装特性
function functionName(name) {
  console.log("所以参数", arguments);
  return name + ",hello";
}

console.log(functionName("mangwu", 1, 2));
// 打印
所以参数 [Arguments] { '0': 'mangwu', '1': 1, '2': 2 }
mangwu,hello
```

- arguments是函数内部可以使用的局部变量，它是所有参数组成的对象

# 8.小结

上述介绍的语言基础特性都是ECMA-262中以**伪语言ECMAScript的形式定义的**

ECMAScript提供了语言的基本语法、操作符、数据类型和对象，能完成基本的计算任务，但是**没有提供获取输入和产生输出的机制**

浏览器中的JavaScript语言基础特性基于ECMAScript规范的语言基础

- ECMAScript的语言基础包括
    1. 数据结构：6种基本（原始）的数据结构和对象
        - Undefined
        - Null
        - Boolean
        - Number: 与其它语言不同，不区分整数和浮点数，只有Number一种数值数据类型
        - String
        - Symbol
        
        ---
        
        - Object: 是一种复杂的数据结构，是ECMAScript中所有对象的基类
    2. 语法：
        - 严格模式为ECMAScript中容易出错的部分施加限制
        - 参考其它语言提供了许多基本操作符，包括数学操作符，布尔操作符，关系操作符，相等操作符，赋值操作符
    3. 流控制语句
        - 大多从其它语言借鉴过来
        - 包括条件语句，循环语句，循环控制语句，标签语句等
    4. 函数：
        - ECMAScript中的函数不需要指定返回值
        - 不返回值的函数默认返回undefined

# 注意

- JavaScript新增了原始数据类型`BigInt`用以表示`number` 表示不到的范围
- 字面量写法为数字+n，如下
    
    ```jsx
    let bigint = 1n
    ```
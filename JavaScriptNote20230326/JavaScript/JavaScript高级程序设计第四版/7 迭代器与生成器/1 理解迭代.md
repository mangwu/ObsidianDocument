# 1. 理解迭代

# 1.1 最基础的迭代

- 计数循环就是一种最简单的迭代
    
    ```jsx
    for(let i = 1; i <=n; i++) {
    	console.log(i);
    }
    ```
    
    1. 设定迭代需要的循环变量
    2. 指定迭代退出的条件（指定迭代的次数）
    3. 定义每次迭代都要执行的操作

> 循环是迭代机制的基础
> 

# 1.2 有序集合的迭代

- 迭代在一个有序集合上进行
- 有序可以理解为集合中所有项都可以按照既定的顺序被遍历
- 数组是JavaScript中有序集合最典型的例子
    
    ```jsx
    const arr = [1, 5, 2, 3, 6, 8];
    for (let i = 0; i < arr.length; i++) {
      console.log(arr[i]);
    }
    ```
    
- 通过递增数组索引的方式进行迭代是**不理想**的
    - [ ]  迭代前需要**事先知道**如何使用**数据结构**。数组每一项都可以通过数组引用，数组索引配合`[]`操作符获取元素，但是有些数据结构的元素获取并非如此简单，如`Map` 、`Set` 都不能直接指定的键或值
    - [ ]  遍历顺序并不是数据结构**固有**的。数组的遍历顺序是索引递增，而其它具有隐式顺序的数据结构无法通过递增这个操作进行迭代，如按照插入顺序的`Map` 和`Set`

# 1.3 内置迭代方法

- ES5新增的`Array.prototype.forEach()` 方法向通用迭代迈进了一大步
    - 假设其它类型的实例也有`forEach` 这个方法，那么就不用考虑遍历顺序问题，数据结构中的元素顺序交由`forEach` 解决
    - 使用`forEach` 方法也不用考虑数据结构中元素获取的问题，因为传入的函数第一个参数默认是数据结构中的元素，例如 `(item) ⇒ {}` `item`就是数据迭代时获取的元素值
- `Set.prototype.forEach()` 例子
    
    ```jsx
    const set = new Set().add(1).add(NaN).add(8);
    set.forEach((item) => console.log(item));
    ```
    
- `forEach` 仍然不是最好的解决方案
    - [ ]  回调结构笨拙，如果有嵌套回调会显的代码混乱
    - [ ]  没有办法标识迭代如何终止，例如想要找到数据结构中的一个元素，对于for循环而言，找到了就可以直接`break;` 退出了，然而`forEach` 一定会遍历完整个数据结构

# 1.4 迭代器模式

- 开发者无需知道如何迭代就能实现迭代操作，就是**迭代器模式**
- 很多语言都实现了这种模式，JavaScript在ECMAScript6以后也支持了
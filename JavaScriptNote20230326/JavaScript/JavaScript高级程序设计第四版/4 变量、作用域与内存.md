# 4. 变量、作用域与内存

ECMA-262规定JavaScript中的变量是**松散类型**的，**变量不过就是特定时间点上一个特定值的名称**而已，所以变量的值和数据类型在脚本生命周期内是可以改变的。

可以随意变更数据类型会让变量很强大，但也会造成不少问题

本章需要理解：

- 区分原始值和引用值
- 执行上下文
- 垃圾回收

# 1. 原始值与引用值

## 描述

- ECMAScript变量指向的数据包含两种不同类型的数据
    - **原始值：primitive value** 就是最简单的数据，前面介绍过的原始数据类型的值就是原始值
    - **引用值：referenece value** 就是由多个值构成的对象
- 六种原始值：Undefined、Null、Boolean、Number、String、Symbol
    - 它们被赋值是被确定为原始值
    - 保存原始值的变量是**按值（by value）**访问的，操作的就是存储在变量中的实际值
- 而对象Object
    - 对象在被赋值给变量时，JavaScript引擎确定它是引用值
    - JavaScript不允许直接访问内存的位置，因此**不能操作对象实际所在的内存空间**
    - 引用值变量（保存对象的变量）实际保存的是对象的**引用（reference），**而非对象本身
    - 保存引用值的变量是按**引用（by reference）**访问的

---

- 注意：在很多语言中，字符串作为对象表示，被认为是引用类型。ECMAScript打破这个规则

## 原始值与引用值各自特性

### 1.1 引用值的动态属性

[1.1 引用值的动态属性](4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/1%201%20%E5%BC%95%E7%94%A8%E5%80%BC%E7%9A%84%E5%8A%A8%E6%80%81%E5%B1%9E%E6%80%A7.md)

### 1.2 复制值

[1.2 复制值](4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/1%202%20%E5%A4%8D%E5%88%B6%E5%80%BC.md)

### 1.3 传递参数

[1.3 传递参数](4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/1%203%20%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0.md)

### 1.4 确定类型

[1.4 确定类型](4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/1%204%20%E7%A1%AE%E5%AE%9A%E7%B1%BB%E5%9E%8B.md)

# 2. 执行上下文与作用域

## 执行上下文

- 和其他语言一样，ECMAScript也有执行上下文（context）的概念
- 执行上下文是相对于一个**变量或函数**而言的，对于一个函数或变量而言：
    - 每个执行上下文都有一个关联的**变量对象（variable object）**
    - 这个上下文定义的所有变量和函数都存在这个**变量对象**中
    - 变量或函数的上下文决定了可以访问哪些数据，以及它们的行为
    - 无法通过代码访问变量对象，但是后台数据处理会用到它
- 上下文在其作用域中所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数

## 全局上下文

- 全局上下文是最外层（作用域）的上下文
- 由于**ECMAScript只作为规范，JavaScript的实现需要宿主环境，不同浏览器或node环境的全局上下文的变量对象可能不一样**
- 全局上下文在应用程序退出后被销毁

### 浏览器上下文

- 在浏览器中，全局上下文就是window
- 因此，**所有通过var定义的全局变量（无论是否在顶层作用域中定义）和函数都是成为window对象的属性和方法**
    - 可以查看上一章节关于var与let关于作用域的说明[let也是用来声明变量的关键字，但和var有很重要的区别，最重要区别在于](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md)
    - **var是函数作用域，只在函数中有局部效应**，在正常的控制流语句中是全局声明且声明提升的
    - let是块作用域，在任何作用域中都是局部变量
- 使用let和const定义的**顶级声明**不会定义在全局上下文上，但是在**作用域链解析**上效果是一样的

## 函数上下文

- 每个函数都有一个上下文，上面的关于var的阐述中，在函数中使用var声明变量，这个变量属于这个函数上下文的变量对象
- 函数上下文创建原理：
    - 当代码执行流进入到函数时，函数上下文被推入到一个上下文栈
    - 执行控制权交给函数上下文
    - 函数执行完毕后，上下文栈弹出该函数上下文，控制权返回给之前执行的上下文
    - ECMAScript程序的执行流就是通过这个上下文栈进控制的

## 上下文中代码执行原理

1. 上下文中的代码在执行时会创建变量对象的一个**作用域链（scope chain）**
    1. 该作用域链决定上下文中代码在访问变量和函数时的顺序
2. **代码正在执行的上下文的变量对象始终位于作用域的最前端**
3. 如果上下文是函数，则其**活动对象（activation object）**用作**变量对象**
    1. 活动对象最初就是一个由传入参数定义的变量：arguments（全局上下文中没有这个变量）
4. **作用域链**中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文，以此类推到全局上下文
    1. **全局上下文的变量对象始终是作用域链的最后一个变量对象**
5. 代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的
    1. 搜索过程始终从作用域的最前端开始，然后逐级往后，直到找到标识符
    2. 如没有找到标识符就会报错

## 例子

- 上述关于上下文中代码执行原理过于抽象，可以对一个简单的例子加以解析
    
    ```jsx
    var color = "blue";
    function changeColor() {
    	if(color == "blue") {
    		color = "red";
    	} else {
    		color = "blue";
    	}
    }
    changeColor();
    ```
    
    - 函数changeColor的作用域链包含两个变量对象：
        - 函数自己的变量对象（即参数定义的arguments对象，即使没有参数）
        - 另一个就是全局上下文的变量对象
    - 这个函数能够找到color，原因
        - 先从作用域链的最前端（函数自己的变量对象）开始查找，没有往后查找
        - 作用域链中的第二个（也是最后一个）变量对象就是全局上下文的变量对象，其中有通过var定义的color变量
        - 这就**完成了一次通过作用域链逐级搜索标识符名称解析变量的过程**
- 局部作用域中的变量可以获取全局变量，也可以通过它替换全局变量
    
    ```jsx
    var color = "blue";
    function changeColor() {
    	let anotherColor = "red";
    	function swapColor() {
    		let tempColor = anotherColor;
    		anotherColor = color;
    		color = tempColor;
    		// 可以访问到三个color
    	}
    	// 只能访问到color和anotherColor
    	swapColor();
    }
    // 只能访问到color
    changeColor();
    ```
    
    - 上面的例子有三个上下文
        - 全局上下文，变量对象中包含color，changeColor函数
        - changeColor局部上下文，变量对象包含anotherColor,swapColor函数
        - swapColor局部上下文，变量对象包含tempColor
    - 在执行每个上下文中的代码时，其中每个上下文的**作用域链**包含不尽相同的变量对象
        - 全局上下文只包含全局变量对象
        - changeColor局部上下文包含changeColor函数上下文的变量对象和全局变量对象
        - swapColor局部上下文包含swapColor函数上下文的变量对象，changeColor函数上下文的变量对象，全局变量对象
    - 每个上下文包含的变量对象越多，可能读取到的变量和函数越多
    - 对于这三中上下文的作用域链，可以使用包含的关系图统一表示：
        
        [https://www.figma.com/file/exnMy8eAh2Hb7vDvm88Rjh/scpoe-chains?node-id=0%3A1](https://www.figma.com/file/exnMy8eAh2Hb7vDvm88Rjh/scpoe-chains?node-id=0%3A1)
        
        - 上图中，不同的矩形表示不同的上下文
            - 最外层的灰色是全局上下文 window
            - 中间层白色是changeColor局部上下文
            - 最里层青色swapColor是局部上下文
        - **内部上下文可以通过作用域链访问外部上下文的一切**
        - 外部上下文无法访问内部上下文中的变量对象
        - 通过图示，可以很好发现，每个作用域链中的变量对象包括本身和上级的所有上下文的变量对象，阐述了[**作用域链**中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文，以此类推到全局上下文](4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98.md) 的原理
    - 在执行swapColor()函数时，
        - swapColor搜寻anotherColor先在自身变量对象中查找，然后再上级上下文的变量对象中找到
        - 搜寻color标识符，本身和上级都没有找到，在全局上下文的变量对象中找到
        - 最后搜寻tempColor，发现本身变量对象之前定义了直接使用即可

## 2.1 作用域链增强

上述阐述了两种主要上下文（全局上下文和函数上下文），还有其他方式来增强作用域链（临时添加一个上下文）

[2.1 作用域链增强](4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/2%201%20%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%A2%9E%E5%BC%BA.md)

## 2.2 变量声明

ECMAScript6规范使得JavaScript的变量声明经历翻天覆地的变化，声明变量不再只有var一种方式。关于变量的声明在[3.变量](3%20%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.md) 中也有提过，主要说明了var是函数作用域，而let是块作用域的区别

[2.2 变量声明](4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/2%202%20%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E.md)

# 3. 垃圾回收

JavaScript是使用垃圾回收的语言，执行JavaScript的环境负责在代码执行时管理内存，例如谷歌浏览器的V8引擎就会负责脚本内存的管理，node环境下，node执行引擎就会负责JavaScript内存的管理

## JavaScript垃圾回收的基本思路

1. 与C，C++不同，在C系列语言中需要编程者自己释放内存，开发者自己管理内存是很大的负担，也是很多问题的来源
2. JavaScript引擎通过自动内存管理实现内存分配和闲置资源回收
    1. 确定哪个变量不会再使用，然后释放它的内存
    2. 这个过程是周期性的，垃圾回收每隔一段时间就会自动运行
3. 垃圾回收是一个近式且不完美的方案，因为某块内存是否还有用是未知的，算法无法解决

### 垃圾回收例子

- 函数中的局部变量的正常生命周期
    1. 函数执行时，为函数中的局部变量分配空间
    2. 栈（或堆）内存会分配空间保存相应的变量值
    3. 函数内部使用变量，在内存中搜寻变量值
    4. 函数执行完毕，不再需要那些局部变量，它占用的内存可以被释放
- 并不是所有时候都这么简单，因为有些变量之后是否还被使用是未知的
    - **垃圾回收程序必须跟踪记录哪个变量**还会使用，哪个不会使用，以便回收内存
    - **标记未使用的变量**在浏览器环境上有两种标记策略：**标记清理和引用计数**

## 3.1-2 垃圾回收实现方式

如何标记未使用的变量并回收，有两种标记策略

[3.1-2 垃圾回收的实现方式](4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/3%201-2%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.md)

## 3.3 垃圾回收的调度

垃圾回收程序的运行是”**周期**“性的，但是”**周期**“的确认和调整会影响JavaScript引擎的性能。差的**垃圾回收时间调度**会导致性能损耗严重，不同的JavaScript引擎有不同的**垃圾回收时间调度**

[3.3 性能](4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/3%203%20%E6%80%A7%E8%83%BD.md)

## 3.4 内存管理

JavaScript引擎都是使用垃圾回收的编程环境，开发者实际**无需关心内存管理**。但是合理的代码写法会对JavaScript引擎的垃圾回收实际上是有间接优化的。

**浏览器环境**

- JavaScript通常运行在一个内存管理和垃圾回收都很特殊的环境——浏览器环境
- 分配给浏览器的内存通常比分配给桌面软件的要少的多，分配给移动浏览器的就更少了
- 出于**安全**考虑，操作系统不会给浏览器环境太多内存，避免运行大量的JavaScript的网页耗尽系统的内存而导致操作系统崩溃
- 这样的**内存限制**不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量

**减少内存消耗的写法**

将内存占用量保证在一个较小的值能让页面性能更好

- 最佳手段：保证在执行代码时**只保存必要的数据**
- 如果数据不必要，就设置为`null` ，释放引用，也叫**解除引用**
    - 适用于全局变量和全局对象的属性
    - 局部变量在超出作用域后会被**自动解除引用**
    - **解除引用不会导致相关内存被回收，而是确保相关值已经不在上下文**了，确保它会再下一次垃圾回收中被释放
- 例如
    
    ```jsx
    let globalPerson = { name: "mangwu", age: 22 };
    
    function printPerson(person) {
      let localName = person.name;
      let localAge = person.age;
      console.log(`${localName} is ${localAge} years old`);
    }
    printPerson(globalPerson);
    globalPerson = null; // 解除引用
    ```
    
    - localName和localAge都是局部变量，在函数执行完毕后自动解除引用，不必显示地解除引用
    - `globalPerson`是一个全局变量，传递给函数`printPerson` 后就没有使用，作为非必要数据，就可以在最后一行主动解除引用

**对内存管理有利的JavaScript代码写法**

[对内存管理有利**的JavaScript代码写法**](4%20%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98/%E5%AF%B9%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%89%E5%88%A9%E7%9A%84JavaScript%E4%BB%A3%E7%A0%81%E5%86%99%E6%B3%95.md)

# 3. 总结

1. JavaScript变量可以保存两种值：原始值和引用值
    1. 原始值是6大原始数据类型，保存在栈内存上
    2. 引用值是对象，存储在堆内存上
    
    ---
    
    1. 原始值按值访问，按值复制
    2. 引用值按引用访问，复制只能复制引用指针，复制变量和原变量指向同一对象
    
    ---
    
    1. typeof 确定值的原始类型
    2. instanceof确定值的引用类型
    
    ---
    
    1. 函数参数传递只有按值传递方式
    2. 原始值传入函数相当于创建一个副本，引用值传入函数只传入指针，函数可以对外部对象进行修改
2. 任何变量都存在于某个执行上下文（作用域），这个执行上下文决定了变量的声明周期
    1. 执行上下文分全局上下文、函数上下文和块级上下文
    2. let、const属于块级作用域，而var属于函数作用域
    
    ---
    
    1. 代码执行流进入一个新上下文会创建一个作用域链，用于标识符搜索
    2. 标识符搜索优先当前的局部上下文，然后一层层搜索父上下文到全局上下文
    
    ---
    
    1. 变量的执行上下文用于确定什么时候释放内存
3. JavaScript是使用垃圾回收的编程语言，但是良好的编码方式有助于JavaScript引擎的内存管理
    1. JavaScript引擎主要使用标记清理策略进行垃圾回收，引用计数因为有循环引用的问题而不被使用
    2. 离开作用域的变量值会被自动标记为可回收，在垃圾回收期间被删除
    
    ---
    
    1. 不同JavaScript引擎使用不同的调度方法周期运行垃圾回收程序
    2. V8引擎根据运行一次垃圾回收程序后，**堆增长策略**会根据**活跃对象的数量外加一些余量**来确定何时再次垃圾回收。
    3. IE使用动态阈值的方式判断是否需要进行垃圾护手
    
    ---
    
    1. 对不再使用的对象**解除引用**可以消除循环引用，有助于内存管理
    2. 使用const, let而不用var有助于内存管理
    3. 对于V8等JavaScript引擎，不要”先创建再添加“对象属性，让同类型对象拥有共享隐藏类，提升性能，方便内存管理
    4. 避免因为坏的代码风格造成内存泄漏，例如意外声明全局变量、一步计时器、闭包等
    5. 为了避免JavaScript引起频繁运行垃圾回收程序拖累整个程序运行，应可能的**复用同类型对象，**通常通过静态分配和对象池策略进行优化，属于提前优化，基本上不会遇到
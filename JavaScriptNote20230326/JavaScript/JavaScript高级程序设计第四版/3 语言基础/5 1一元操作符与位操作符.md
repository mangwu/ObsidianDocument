# 5.1一元操作符与位操作符

只操作一个值的操作符叫一元操作符（unary operator），它是ECMAScript中最简单的操作符

# 5.1.1递增/递减操作符

## 描述

- 递增/递减操作符照**搬自C语言**
- 它们能对**数字变量**进行自增或者自减
- 递增/递减操作符有两个版本：**前缀版本和后缀版本**

## 前缀版本的递增/递减操作符

### 语法

- 放在被操作的数字变量前面，对变量进行递增或者递减
    
    ```jsx
    let age = 19;
    ++age;
    console.log(age); // 20
    --age;
    console.log(age); // 19
    ```
    

### 特性

- 前缀递增/递减操作符会在语句**被求值之前改变变量的值**
- 在计算机科学中，这通常被称为**副作用**
    
    ```jsx
    let age = 19;
    // 前缀版本在求值之前改变变量的值
    console.log(--age + 2); // 20
    ```
    
- 前缀递增和递减的操作符优先级相等，会从左到右依次求值

## 后缀版本的递增/递减操作符

### 语法

- 放在数字变量的后面，对变量进行自增或自减操作,通常情况下和前缀没什么区别
    
    ```jsx
    let age = 19;
    age++;
    console.log(age); // 20
    age--;
    console.log(age); // 19
    ```
    

### 特性

- 和前缀递增/递减操作符的唯一区别在于，后缀递增/递减操作符会**在语句被求值之后改变变量的值**
    
    ```jsx
    let age = 19;
    // 后缀版本在求值之后改变变量的值
    console.log(age-- + 2); // 21
    ```
    

## 作用变量类型

- 通常，递增/递减操作符**多作用于数字变量**，包括整数与浮点数
- 实际上，递增/递减操作符可以**作用于任何值**，包括字符串，布尔值，浮点值，对象

| 作用变量类型 | 作用结果 |
| --- | --- |
| 有效的数值字符形式（只包含数字字符，+，-，小数点） | 转化位数字后再应用，变量从字符串变为数值，例如c=”12.5”;c++; c变为13.5 |
| 无效的数值字符形式 | 会将变量值设置为NaN，属于数值类型 |
| 布尔值 | flase转化为0，true转化为1，再进行改变，如b=true;b++;b变为2 |
| 对象 | 调用valueOf()方法取得原始数据类型后再按照原始数据类型的方式进行作用，如果结果是NaN就会调用toString()再次应用其它规则将对象转化为数值后进行操作 |
| Undefined | NaN |
| null | 空会被转化为0，然后进行递增或者递减 |

```jsx
let b = true;
let c = null;
let d = {
  toString() {
    return "12.3";
  },
  valueOf() {
    return "d";
  },
};
let e = 1.1;
let f = "num";
console.log(++b);
console.log(++c);
console.log(++d);
console.log(--e);
console.log(++f);
// 打印
2
1
NaN // 和书说的情况不同
0.10000000000000009 // 浮点数的精度问题
NaN
```

⇒ 对于对象，有valueOf()方法就调用`valueOf()` 之后就不会调用`toString()`,没有就调用`toString()`

# 5.1.2一元加和减

## 描述

- ECMAScript规范中的一元加和减操作符就是初中数学中的表示数字符号的`＋`和`-`

## 语法

- 一元加和减操作符放在变量前面，**可能**对变量进行改变
    
    ```jsx
    let c = 45
    -c; // -45
    +c; // 45
    ```
    

## 一元加操作符

- 一元加（+）操作符号放在**数值变量**前面，不会对数值有任何影响
- 如果将一元加放在**非数值变量**前面，则会执行使用**Number()**一样的转型函数进行类型转换
- 对于非数值类型的其它类型变量，一元加操作符对变量的类型转换和前面的递增/递减操作符[**类似](5%201%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6.md)** 只是只对变量进行到数值类型的转换
    
    ```jsx
    console.log(+null);
    console.log(+undefined);
    console.log(+"123");
    console.log(+"a123");
    console.log(
      +{
        valueOf() {
          return "3";
        },
      }
    );
    console.log(+true);
    
    // 打印
    0
    NaN
    123
    NaN
    3
    1
    ```
    

## 一元减操作符

- 和一元加操作符不同是：
    - 对于数值变量，像高中数学一样**设置数值的符号**
    - 对于非数字变量，先将其转化为数值变量，再设置数值的符号

## 作用

1. 数值的基本算术
2. 数据类型转换

# 5.1.3位操作符

位操作符号都是作用于数值的**底层操作，**也就是**操作内存中表示数据的比特位**

## 底层数值存储

ECMAScript规范所以数值都以**IEEE 754 64位**格式存储

> 但是位操作并不直接应用到64位表示，而是**先把值转化为32位整数**，再进行位操作，之后再把结果转化为64位
> 

对于开发者，只需要了解**32位整数**是如何存储，如被操作即可，因为64位整数存储格式是不可见的

### 32位整数

- 有符号整数
    - 使用32位的前31位表示整数值
    - 第32位（称为第31位）表示数值的符号，0为正，1为负，这一位称为**符号位**
    - **符号位的数值决定了其它31位的格式**
    
    ---
    
    1. 符号位为0，值为正值，**其余31位以真正的二进制格式进行存储**
        - 31位中的每一位的位置代表2的幂，称为**位权**
        - 第一位（称为第0位）位权为$2^0$ ，第二位（称为第1位）位权$2^1$
            
            ---
            
        - 31位中的每一位的值，代表在每个位权的值
        - 可选值个数是基数(2)个,范围为[0,2)的整数
            
            ---
            
        - 二进制表示的十进制数值就是每一位的值乘以维权求和
            
            $y = \sum_ {i = 0}^{30}f(i) * 2 ^i ,f(i) 表示第i位的值，0或1$
            
            ---
            
        - 例如18的二进制格式为
            
            0**000 0000 0000 0000 0000 0000 0001 0010**
            
            符号位(1) + 数值位(31)
            
            十六进制 ⇒ 0000 0012
            
            - 有效位数：**10010**
            - $y = 1 * 2^4 + 0 * 2^3 + 0 * 2 ^2 + 1 * 2^1 + 0 * 2 ^0$
    2. 符号位为1，值为负数，其余31位以**补码的二进制编码进行存储**
        - 十进制负数的补码确定方式
            1. 确定绝对值的而进制表示，如-18，先确定18的二进制表示
            2. 找到绝对值数的补数（**反码**），0变为1，1变为0
            3. 给结果加1
            
            ---
            
        - 例子，-18
            1. 18的二进制：0**000 0000 0000 0000 0000 0000 0001 0010**
            2. 补码：1111 1111 1111 1111 1111 1111 1110 1101
            3. 加1：1111 1111 1111 1111 1111 1111 1110 1110
                
                十六进制 ffff ffee
                
            
            ---
            
        - 实际上，正整数数与负整数的编码范围的十进制对二进制(这里使用十六进制进行简化)有如下映射关系：
            
            $[0, 2^{31} - 1], [-2^{31},-1]$  ⇒ [0000 0000, 7fff ffff], [8000 0000, ffff ffff]
            
            - 这里每个区间中的整数都是递增1的
            - $-2^{31}$  是32位的最小负整数，使用”**负数0**“表示，二进制刚好比32位最大整数大一（7fff ffff ⇒ 8000 0000）
    3. ”处理有符号整数时，无法访问第31位“ （这里的31位就是最左边的符号位）
        - 在解释整数的二进制位时，习惯上**从数字0开始进行数位**
        - **位数的数法习惯上从右向左数**
        - 所以第31位就是符号位
        - 前31位表示从右向左数共31个的数值位
        - 用o表示数值位，x表示符号位，32位有符号整数如下
            
            $oxxx\space xxxx\space xxxx\space xxxx\space xxxx\space xxxx\space xxxx\space xxxx$
            
            31                                                                                  0
            
- 无符号整数
    
    > 默认情况下，ECMAScript中所有整数**都表示为有符号数**
    > 
    - 无符号数的第31位不表示符号，用来表示数值

### 获取数字的二进制表示

- 使用数字的toString()方法，填入需要获取的进制的**基数**即可得到对应的进制数表示
- 对应二进制，传入数字2即可得到数字的二进制字符串表示
    
    ```jsx
    let num = 5;
    num.toString(2); // "101"
    ```
    
- 对于负整数，toString方法只是得到绝对值的正整数的二进制，再在前面添加一个负数符号“-”,无法得到负数的实际**补码**表示，但是在toString()的实际计算过程中会得到二补数

### 注意

- 由于ECMAScript规范，将数值在应用位操作符时，后台将64位转化为32位数值，执行位运算后，再把结果转化为64为存储起来
- 这种转化方式导致了副作用⇒ **特殊值，如NaN和Infinity在位操作中当作0处理**
    
    ```jsx
    console.log(~NaN); // -1  相当于 ~0
    console.log(5 ^ NaN); // 5 相当于 5 ^ 0
    ```
    
- 位操作符应用到非数值，首先使用Number()函数将其转化位数值（自动的），然后应用位操作

## 5.1.3.a 按位非

### 描述

- 按位非操作符，使用波浪符号表示，放在数值变量的前面，返回数值的补数，属于一元操作符
- 补数就是将数值的二进制位进行”翻转“，0→1,1→0**,包括符号位**

### 语法与特性

- 将`~`放在数值变量前即可进行按位非操作
    
    ```jsx
    let num = 25;
    console.log(~num);
    // -26
    ```
    
    - 25： 0x00000019 0b0000 0000 0000 0000 0000 0000 0001 1001
    - -26:  0xffffffe3 0b1111 1111 1111 1111 1111 1111 1110 0110
- 使用`~` 相当于对数值取负数然后减去1
    
    ```jsx
    let num3 = Math.floor(Math.random() * Math.pow(2, 31));
    console.log(num3);
    console.log(~num3 == -num3 - 1); // true
    ```
    
    ⇒ 对包括符号位的二进制进行翻转，符号位肯定会变化
    
    - 如果原始值为正整数，按位非后，符号位由0变为1，变为负数
        - 其他位取反，同时按照**补码**的格式读取31位的数值位
        - 为了得到十进制大小，对按位非后的二进制**减1取反（补码的反规则）**即得到数值的十进制绝对值
        - 数值位被取反后被减去一位再取反，相当于十进制取负后减去一位，即-num-1
    - 同理，如果原始值为负整数，按位非后，符号位由1变为0，变为正数
        - 其他位取反，按照正常进制格式读取31位的数值位
        - 因为原始数值（负数）为补码，其**原始值绝对值**得到方式为**减1取反**，现在直接取反，相当于减去了1，例如-1的补码为0xffffffff, 减去1取反得到0x00000001,即1，直接取反为0x00000000 ,所以相当于减去了1，即-num - 1
- **按位非操作**比**取反减1**速度更快，因为位操作是在数值底层表示上完成的

## 5.1.3.b 按位与

### 描述

- 使用和号(&)表示按位与，有两个操作数，属于二元操作符
- 本质上按位与就是将两个数的**每一位（包括符号位）**的数值对齐，然后按照与操作的真值表得到结果
- 与操作原则：只有两位都为1的情况下才返回1，其他情况返回0

### 与操作真值表

| 第一个数值的位 | 第二个数值的位 | 结果 |
| --- | --- | --- |
| 1 | 1 | 1 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 0 | 0 | 0 |

### 例子

- -3 & 2
- 1111 1111 1111 1111 1111 1111 1111 1101 (-3) &
- 0000 0000 0000 0000 0000 0000 0000 0010 (2)
- 0000 0000 0000 0000 0000 0000 0000 0000 (0)
    
    ```jsx
    console.log(-3 & 2); // 0
    ```
    
- 结论：由按位非的结论可知，**任何数**与**其按位非的数**进行**按位与**操作结果都是0
- 更进一步，**任何数**与**其取负减1后的数**进行**按位与**的操作结果都是0
    
    ```jsx
    // 按位与 &
    // 任何数与其取负减1后的数相与都是0
    // 因为取负减1的数就是按位非后的数
    let num = Math.floor(Math.random() * Math.pow(2, 31));
    console.log(num);
    console.log((num & (-num - 1)) == 0); // true
    ```
    

## 5.1.3.c 按位或

### 描述

- 按位或操作符使用管道符(|)表示，有两个操作数，属于二元操作符
- 和按位与一样，它遵循按位或的真值表对两个数的每一位进行按位或操作

### 真值表

| 第一个数值的位 | 第二个数值的位 | 结果 |
| --- | --- | --- |
| 1 | 1 | 1 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 0 | 0 | 0 |
- 按位与的特性是：只要有一位数值为1就返回1，只有当两个都是0时才返回0

### 例子

- -3 | 2
- 1111 1111 1111 1111 1111 1111 1111 1101 (-3) &
- 0000 0000 0000 0000 0000 0000 0000 0010 (2)
- 1111 1111 1111 1111 1111 1111 1111 1111(-1)
    
    ```jsx
    console.log(-3 | 2); // -1
    ```
    
- 结论，**任何数**和**其按位非的数**进行**按位或**操作都会得到-1
- 进一步，任何数和其取负减1后的数进行按位或操作都会得到-1
- 因为32位都是取反后的结果，即都是1-0或是0-1对，按位或得到0xffffffff 即-1
    
    ```jsx
    const num = Math.floor(Math.random() * Math.pow(2, 31));
    
    console.log(num, (num | (-num - 1)) == -1); // num true
    ```
    

## 5.1.3.d 按位异或

### 描述

- 按位异或使用脱字符(^)表示,两个操作数，二元操作符
- 按照按位异或真值表对没一位进行异或操作

### 按位异或真值表

| 第一个数的位 | 第二个数的位 | 结果 |
| --- | --- | --- |
| 1 | 1 | 0 |
| 1 | 0 | 1 |
| 0 | 1 | 1 |
| 0 | 0 | 0 |
- 特性：只有两个位是不同值（即1-0对）时才返回1，相同值时返回0

### 例子

- -3 ^ 2
- 1111 1111 1111 1111 1111 1111 1111 1101 (-3)
- 0000 0000 0000 0000 0000 0000 0000 0010 (2)
- 1111 1111 1111 1111 1111 1111 1111 1111(-1)
    
    ```jsx
    console.log(-3 ^ 2); // -1
    ```
    
    - 和按位或一样的特性，**所有数**和**其按位非后的数**进行**按位异或**操作后会得到-1
- 除此之外，**所有相同数按位异或都会得到0**
    
    ```jsx
    const num = Math.floor(Math.random() * Math.pow(2, 31));
    console.log((num ^ num) == 0); // true
    ```
    
    - 因为32位都是相同数值对（1-1，0-0），按位异或后都会得到0
- 所有**数按位异或0都会得到本身**
    
    ```jsx
    const num = Math.floor(Math.random() * Math.pow(2, 31));
    console.log((num ^ 0) == num); // true
    ```
    
    - 由真值表：1-0 ⇒ 1; 0-0⇒0; 所以num的每一位与0异或都会得到原始位值

## 5.1.3.e 左移

### 描述

- 左移操作符使用两个小于号（<<）表示，有两个操作数，左边的操作数位被左移的数，右边的操作数位左移的位数，按照指定的位数对左边的数将”**所有位**“向左移动
- 左移后右边空出来的位置补0

### 未溢出时

- 未溢出时，**左移不移动符号位（或者说符号位不受影响）**
- 32位整数的范围[-2147483648, 2147483647] ([-2^31, 2^31 - 1])
- 假设左移位数为n，**左移相当于将数的绝对值扩大到$2^n$ 倍**
- 例如数7左移3位，相当于$7 * 2 ^3 = 56$
    
    7： 0000 0000 0000 0000 0000 0000 0000 0111
    
    56:  0000 0000 0000 0000 0000 0000 0011 1000
    

### 溢出时

- 溢出时，符号位可能发生改变
- 对于正数，在**数值位中的最高位1，距离符号位的距离**就是不溢出左移时的最大距离
- 对于负数，在**数值位中的最高位0，距离符号位的距离**就是不溢出右移时的最大距离

---

- 例如7，最高位1在第2（从0开始）位，距离最左边的符号位有 28（31 - 2 - 1）位
- 7左移28位，相当于$7 * 2 ^{28} = 1879048192$
    
    7：  0000 0000 0000 0000 0000 0000 0000 0111
    
    max:0111 0000 0000 0000 0000 0000 0000 0000 
    

---

- 如果将7左移29位，这个时候发生溢出：
    
    7<<29: 1110 0000 0000 0000 0000 0000 0000 0000  (-536870912) $-2^{29}$
    
    符号位变为1，成为负数，数值位按照补码形式输出，其对应的绝对值为
    
    $2^{29}$:      0010 0000 0000 0000 0000 0000 0000 0000
    

---

- 将7左移30位
    
    7<<30: 1100 0000 0000 0000 0000 0000 0000 0000  (-1073741824) $-2^{30}$
    
    数值位按照补码形式输出，对应绝对值为
    
    $2^{30}$ :      0100 0000 0000 0000 0000 0000 0000 0000 
    

---

- 将7左移31位，得到32位整数的最小值
    
    7<< 31: 1000 0000 0000 0000 0000 0000 0000 0000 (-2147483648) $-2^{31}$
    
    数值位按照补码形式输出，对应的绝对值的二进制就是“正0”
    

---

- **将7左移32位，得到原始值**
    - **任何在32位数范围（[-2147483648, 2147483647] ）内的数左移32位都会得到原始值**
    - 所以之后左移33位就相当于左移1位了
    - 在JavaScript能表示的数值范围内，**任何在32位数范围内的数左移x位相当于左移x%32位**
    
    ```jsx
    // 左移
    // 左移不溢出的最大位为被左移数的最高位距离符号位中0的个数
    // 对于32位整数范围内的任何数，它左移的位数以32位为一个周期，左移32位会变为原始数值
    let k = Math.floor(Math.random() * Math.pow(2, 31));
    const num = Math.floor(Math.random() * 2) ? k : -k;
    
    console.log(num << 32 == num); 
    console.log(num << 33 == num * 2);
    console.log(num << 34 == num * 4);
    // 打印结果
    true
    true
    true
    ```
    

## 5.1.3.f 有符号右移

### 描述

- 有符号右移由两个大于号（>>）表示，两个操作数，二元位操作符
- 左边的操作数为被右移数，右边的数为右移位数
- 有符号右移会将所有32位向右移，同时**保留符号**
- 这里的有符号实际上指在右移时，**空白位填充符号位**

### 特性

- 有符号右移实际上就是左移的逆运算
    - 在实际值数值上将数缩小到$2^{-n}$ n是右移位数
    - 例如将48右移3位，相当于除以8,结果为6
        
        110000 >> 3
        
        000110 ⇒ 6
        
- 右移出现的空位在**符号位右边**，即左侧，ECMAScript**使用符号位**的值来填充这些空位，
    - 非负数右移，左侧补0，数值变小
        - 正数右移能起效果的**最大移动位数**为：最高位1到第0位的距离
        - 超过最大移动位数，右移不起效果，结果变为**非负数右移的最终值0**
        - 例如48最大移动位数为6，移动位数增大后没有效果，结果一直是0
            
            110000 ⇒ 最高位1到第0位长6位
            
            ![Untitled](5%201%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6/Untitled.png)
            
    - 负数右移，左侧补1，数值指数变小（仍然是负数）
        - 负数右移能起效果的**最大移动位数**为：最高位0到第0位的距离
        - 超过最大移动位数，右移不起效果。结果变为**负数右移的最终值-1**
        - 因为左侧补1，右移位足够大一定是0xffffffff(-1)
        - 例如-48，最大移动位数为6
            
            0xffffffb0 ⇒ 1101 0000 (后8位) ⇒ 最高位0到第0位长6位
            
            ![Untitled](5%201%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6/Untitled%201.png)
            
    
    ```jsx
    // 有符号右移,左侧补位为符号位
    // 负数右移最终值-1
    // 正数右移最终值0
    
    let num = Math.floor(Math.random() * Math.pow(2, 31));
    
    console.log(num >> 31, -num >> 31);
    // 打印
    0
    -1
    ```
    
- 和左移类似，**任何在32位数范围（[-2147483648, 2147483647] ）内的数有符号右移32位都会得到原始值**
    - 右移33位相当于右移1位
    - 在JavaScript能表示的数值范围内，**任何在32位数范围内的数有符号右移x位相当于右移x%32位**

### 注意

- 上面48和-48的最大移动位数相同，但是在右移5位时，二者的**结果值不是相反数**
- 有符号右移实际上就是把数值缩小到$2^{-n}$ ，如果结果是**小数，就会进行向下取整的操作**
    - -48 >> 5相当于 -48 / 32 = -1.5
    - 48 >> 5 相当于 48 / 32 = 1.5
    - 向下取整就是省略小数，结果整数要**小于等于**原始浮点数(`Math.floor`)
    - $\lfloor1.5\rfloor = 1$, $\lfloor-1.5\rfloor = -2$
    - 所以结果不是相反数

## 5.1.3.g 无符号右移

### 描述

- 无符号右移由三个大于号（>>>）表示，两个操作数，二元操作符
- 左边的操作数被称为被无符号右移的数，右边的操作数为移动位数
- 无符号右移对于数值的符号位不关心，因为**右移多出的空位默认使用0填充**
- 所以对于**正数**而言，无符号右移和有符号右移***没有区别***
- 对于负数而言，结果差异可能很大，因为符号位同样被右移

### 特性

- 因为符号位被右移会补0，所以32位的**负数**会被右移1位就会成为正数
- 对于正数而言，无符号右移与有符号右移没有区别，查看**[有符号右移特性](5%201%E4%B8%80%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B8%8E%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%AC%A6.md)**即可
- 以-1为例子，关于无符号右移的规律：
    - -1的二进制：1111 1111 1111 1111 1111 1111 1111 1111
    - -1>>>1:        0111 1111 1111 1111 1111 1111 1111 1111 ⇒ 2147483647
    - -1>>>2:        0011 1111 1111 1111 1111 1111 1111 1111 ⇒ 1073741823
    - -1>>>x:(1≤x≤31) ⇒ x个0，32 - x个1 ⇒ $2^{(32-x)} - 1$
    - -1>>>31:      0000 0000 0000 0000 0000 0000 0000 0001 ⇒ 1
    - -1>>>32:      1111 1111 1111 1111 1111 1111 1111 1111 ⇒$2^{32} - 1$
    - -1>>>33:      0111 1111 1111 1111 1111 1111 1111 1111 ⇒ 2147483647
    
    ---
    
- 负数的**无符号右移也以32位为一个周期进行**
    - 区别在于，**左移，有符号右移，非负数无符号右移32位都是原始值**
    - 但是**负数的无符号右移32位是无符号整数，**即原先的符号位1表示数值了，所以**-1>>> 32 == $2^{32} - 1$**
    - 这一结论仍然不变：**任何在32位数范围内的数无符号右移x位相当于右移x%32位**

### 注意

- 无符号右移得到的结果是**无符号整数（**这也是为什么-1右移32位变为32位无符号整数最大值的原因**）**
- 负数可以无符号右移0位得到对应的无符号整数
    
    ```jsx
    -1 >>> 0 === -1 >>> 32 // true
    ```
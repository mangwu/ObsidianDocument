# 2.1RegExp描述

# 1.1 语法

- JavaScript中的RegExp引用类型支持类似Perl的**简洁语法**来创建正则表达式
    
    ```jsx
    let expression = /pattern/flags
    ```
    

## 简洁语法解释

- pattern表示模式，是正则表达式用于匹配字符的符号表示，它可以是任何简单或复杂的表达式
    - 可以使用字符类、限定符、分组、向前查找和反向引用
- 斜杠包裹模式（pattern），是一种表示正在声明一个正则表达式实例的语法
- flags放在最后，表示标记，标记使用单个字符表示，可以有多个，用于控制正则表达式的行为
    - g：global，全局模式，表示正则模式进行全局匹配，需要查找字符串的全部内容，而不是匹配到第一个就结束
    - i：ignore，不区分大小写，表示在查找匹配时忽略pattern个字符串的大小写
    - m：multiline, 多行模式，将开始（^）和结束($)符号作为多行处理，匹配字符串一行的开始和结束（由\n活\r分隔），而不仅仅是整个输入字符串的开始或结束
    - y: sticky, 粘附模式，表示只查找从lastIndex开始即之后字符串。lastIndex是一个正则表达式的属性，用来指定下一次匹配的起始索引，只有当使用了全局匹配，该属性才有意义
    - u：Unicode模式，将模式（pattern）视为Unicode编码序列
    - s：dotAll模式，允许元字符.匹配任何字符（包括\n和\r）

# 1.2 创建正则表达式

## 一般通过简洁语法创建

```jsx
let pattern1 = /art/g; // 匹配字符串的所有art
let pattern2 = /[bc]at/i; // 匹配字符串的第一个bat或cat，匹配时忽略大小写
let pattern3 = /.at/gi; // 匹配所有以at结尾的三字字符，忽略大小写
```

- pattern3不能匹配`"\nat"` 这种形式的字符，因为`.`默认不能匹配`\n` 这种转义字符

## 元字符

- 上述简洁语法中使用了`[bc]` 表示在其中字符中选取一个字符，`.` 表示匹配除了转义字符外的任意字符
- [、]、. 这些都是**元字符**
    - 元字符在正则表达式的模式中表示**特殊的含义**，用于丰富正则表达式的功能
    - 如果没有**元字符**，那么模式只能使用普通字符，匹配也就只能进行固定字符的匹配，匹配功能忙不了需求
    - 如果要匹配元字符本身，就需要将元字符进行转义，例如匹配`.` 这个字符，为了让它表示字符点本身的函数，可以写成`\.` 仅仅匹配字符点
- 所有的**元字符**
    
    ```jsx
    ( [ { \ ^ $ | ) ] } ? * + .
    ```
    
- 上面的例子使用反斜杆转义元字符的特殊含义
    
    ```jsx
    let pattern2 = /\[bc\]at/i; // 匹配字符串的第一个[bc]at，匹配时忽略大小写
    let pattern3 = /\.at/gi; // 匹配所有.at，忽略大小写
    ```
    

### 注意

- 反斜杆(\)本身包含特殊含义，所以要匹配反斜杆，需要再用反斜杆近转义，例如`\\` 就可以匹配一个反斜杆
- 匹配正斜杆同样需要进行转义，因为斜杆是包裹模式的，具有语法含义
- 只是在字符串中，反斜杆也有用于转义的特殊含义，所以要匹配字符串中的反斜杆，字符也需要将反斜杆转义后才能被匹配
    
    ```jsx
    let pattern4 = /\\\//g;
    console.log([..."/\\/\\//\\/".matchAll(pattern4)]);
    // 相当于匹配 \/ 
    // 在字符串中\/ 使用 \\/ 表示
    // 所以打印为
    [
      [ '\\/', index: 1, input: '/\\/\\//\\/', groups: undefined ],
      [ '\\/', index: 3, input: '/\\/\\//\\/', groups: undefined ],
      [ '\\/', index: 6, input: '/\\/\\//\\/', groups: undefined ]
    ]
    ```
    

## 构造函数创建正则表达式

### 语法

```jsx
const regexp = new RegExp(pattern [,flags]);
```

- pattern：模式，可以是字符串，也可以是其它正则表达式实例
- flags，可选参数，字符串形式，如`"gi"`
- 如果传入的pattern是已有的正则表达式实例，那么传入flags会**覆盖**原有的标志

### 例子

```jsx
pattern1 = new RegExp("art", "g"); // /art/g
pattern2 = new RegExp("[bc]at", "i"); // /[bc]at/i
pattern3 = new RegExp(".at", "gi"); // /.at/gi
pattern2 = new RegExp("\\[bc\\]at", "i"); // /\[bc\]at/i
pattern3 = new RegExp("\\.at", "gi"); // /\.at/gi
```

- 元字符在字符串中直接传入构造函数，构造函数可以识别
- 如果需要转义元字符，匹配元字符的原始字符，就需要将元字符进行转义，所以需要使用反斜杆，而使用**两次**反斜杆的原因在于，字符串中的反斜杆本身是**[有转义功能](2%201RegExp%E6%8F%8F%E8%BF%B0.md)**的特殊含义的，所以需要对字符串反斜杆再进行转义成普通反斜杆，这样构造函数在识别字符串时，识别到**反斜杆+元字符，** 就会对去除元字符串的特殊含义，转而匹配元字符本身表示的字符
- 如果知道了一个字面量形式的正则表达式，将其中的模式转化为字符串传入构造函数中**只需要将所有反斜杆额外加一个反斜杆**即可，例如
    
    
    | 字面量模式 | 对应的字符串 |
    | --- | --- |
    | /\.at/ | “\\.at” |
    | /\w\\hello\\123/ | “\\w\\\\hellow\\\\123” |
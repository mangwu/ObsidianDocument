# 2. 创建对象

不同于在[理解对象](1%20%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1.md)中说明的两种简单的创建对象的方式，即Object构造函数创建对象和对象字面量创建对象：这些方法在需要创建多个具有相同接口的对象时需要重复编码很多次

本节创建对象的方式和ECMScript6引入的类有关，类的引入让创建多个具有相同接口的对象更加的容易了

# 2.1 概述

- ECMAScript5.1 没有正式支持面向对象的结构，比如类或继承，但是巧妙地利用**原型式继承**可以成功地模拟同样的行为
- ECMAScript6 开始正式支持**类和继承** ES6的类旨在**完全覆盖**之前规范设计的基于原型的继承模式，不过从底层实现来看，ES6的类仅仅是**封装了ES5.1构造函数加原型继承的语法糖**
- **注意**
    - 理解ES6类出现前的继承模式是有好处的，特别是ES6的类定义本身就相当于对原有结构的封装
    - 在ES6类之前，本章会循序渐进地介绍被类取代的底层概念
    - 但是不用误解：采用**面向对象编程模式**的JavaScript代码还是应该使用ECMAScript6的类（使用ES6之前的继承语法是兼容的，但是不推荐）

# 2.2 工厂模式

- 工厂模式是一种广泛应用于软件工程领域的设计模式，用于**抽象创建特定对象**的过程
- JavaScript高级程序设计（第4版）没有过多解读，如下页是在网上查找的资料
    
    [JavaScript设计模式：工厂模式](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md)
    
- 下面的一个例子是一种按照特定接口创建对象的方式
    
    ```jsx
    function createPerson(age, name, job) {
      let o = new Object();
      o.name = name;
      o.age = age;
      o.job = job;
      o.sayHello = function () {
        console.log(`Hello, I'm ${this.name}`);
      };
      return o;
    }
    const p = createPerson(23, "mangwu", "software engineer");
    console.log(p);
    p.sayHello();
    // 打印
    {
      name: 'mangwu',
      age: 23,
      job: 'software engineer',
      sayHello: [Function (anonymous)]
    }
    Hello, I'm mangwu
    ```
    
- 这个`createPerson` 接受三个参数，用这几个参数构造一个包含`Person` 信息的对象
- 虽然这个方法能解决创建多个类似对象的问题（重复代码），但是没有解决**对象标识**的问题（即新创建的对象是什么类型）

# 2.3 构造函数模式

## 2.3.1 构造函数语法

- ECMAScript中的构造函数是用来创建特定类型对象的，如JavaScript内置的`Obejct`和`Array`这样的原生构造函数
- 构造函数不仅可以使用原生的，也可以自定义构造函数，JavaScript中以函数的形式为自己的对象类型定义属性和方法，如下
    
    ```jsx
    function ObjectName(prop1, prop2, ... ,propn) {
    	this.prop1 = prop1;
    	this.prop2 = prop2;
    	...
    	this.propn = propn;
    	// 自定义自有方法
    	this.method1 = function() {
    		...
    	}
    	...
    	this.methodn = function() {
    
    	}
    }
    // 自定义实例方法
    ObjectName.prototype.methodx = function() {
    	...
    }
    // 自定义静态方法
    ObjectName.methods = function() {
    	...
    }
    ```
    
    - 与工厂模式的区别在于
        - 没有显式的创建对象
        - 属性和方法直接赋值给`this`
        - 没有`return`
    - 通过赋值给`this`  的方法`this.methodi`属于**自有**(**own**)方法
    - 通过原型链创建的方法`ObjectName.proptotype.methodx` 属于**原项链**上的实例方法
    - 通过赋值给函数的方法(`ObjectName.methods`)属于**静态**(**static**)方法
    - 另外要注意构造函数的首字母要大写，而非构造函数的要小写，这是从面向对象编程语言哪里借鉴的，有助于区分构造函数和普通函数
- 例子
    
    ```jsx
    function Person(age, name, job) {
      this.age = age;
      this.name = name;
      this.job = job;
      this.sayName = function () {
        console.log(this.name);
      };
    }
    Person.prototype.sayHello = function () {
      console.log(`Hello, I'm ${this.name}`);
    };
    ```
    

### 2.3.1.1 构造函数实例化语法

- 通过构造函数创建一个对象实例，需要使用`new`操作符
    
    ```jsx
    const n = new ObjectName(arguments);
    ```
    
    - `arguments` 是需要传递给构造函数的实例化的参数
- 使用`new`操作符调用构造函数会执行一下操作
    1. 在内存中创建一个新对象
    2. **这个新对象的内部的[[Prototype]]特性被赋值为构造函数的prototype属性**
    3. 构造函数内部的`this`被赋值为这个新对象 即`this`指向新对象
    4. 执行构造函数内部的代码（给新对象添加属性）
    5. 如果构造函数返回非空对象，则返回该对象；否则返回刚创建的新对象
- 例子 使用上面构建的`Person`构造函数
    
    ```jsx
    const person1 = new Person(23, "mangwu", "Software Engineer");
    const person2 = new Person(22, "wumang", "Software Engineer");
    ```
    
- 这个例子中`person1` `person2` 分别保存着`Person`的不同实例，两个对象都有一个`constructor`属性指向`Person`
    
    ```jsx
    console.log(person1.constructor === Person); // true
    console.log(person2.constructor === Person); // true
    ```
    
    - 实际上`person` 实例上的`constructor`属性就是从`Person` 的`proptotype` 属性上”*继承”*的,如下是`Person`的`prototype`属性
        
        ![Untitled](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Untitled.png)
        
        - 可以看到`sayHello` 是自定义的实例方法
        - `constructor` 属性声明时就存在，指向构造方法本身
        - 构造方法的[[Prototype]]特性被赋值为`Object` 的`proptotype` 这样从侧面说明`Object` 时所有对象的基类
    - `person1` 实例打印如下
        
        ![Untitled](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Untitled%201.png)
        
        - `person1` 实例的[[Prototype]]特性确实被赋值为了`Person` 的`prototype` 属性
        - `sayName` 是实例的自有(**own**)方法，因为它不在原型链上
        - `sayHello` 是定义在`Person`的`prototype`属性上的方法，属于实例继承与原型链的方法
- `constructor`本来是用来标识对象类型的，不过一般认为`instanceof`操作符是对确定对象类型更可靠的方式(~~实际上instanceof也是在对象的原型链上查找`constructor` 属性判断是否是该构造函数的实例~~)
    
    ```jsx
    console.log(person1 instanceof Person); // true
    console.log(person1 instanceof Object); // true
    ```
    

### 2.3.1.2 构造函数创建对象的好处

- 相比于工厂模式，构造函数创建的对象可以确保实例被**标识**为特定类型
- 所有自定义对象都继承自`Object` ，自定义对象可以使用`Object` 定义的实例方法

### 2.3.1.3 构造函数其它声明方式

- 构造函数不一定要写成函数声明的模式，赋值给变量的**函数表达式**也可以表示构造函数
    
    ```jsx
    let ObejctName = function(prop1, prop2, ... ,propn) {
    	this.prop1 = prop1;
    	this.prop2 = prop2;
    	...
    	this.propn = propn;
    	// 自定义自有方法
    	this.method1 = function() {
    		...
    	}
    	...
    	this.methodn = function() {
    
    	}
    }
    // 自定义实例方法
    ObjectName.prototype.methodx = function() {
    	...
    }
    // 自定义静态方法
    ObjectName.methods = function() {
    	...
    }
    ```
    
- 在实例化时，如果不想传递参数，可以使用参数默认值，或者直接不定义参数，属性直接赋上固定值
    
    ```jsx
    let ObejctName = function(prop1=defaultVal) {
    	this.prop1 = prop1;
    	this.prop2 = FixValue2;
    	...
    	this.propn = FixValue;
    	// 自定义自有方法
    	this.method1 = function() {
    		...
    	}
    	...
    	this.methodn = function() {
    
    	}
    }
    // 自定义实例方法
    ObjectName.prototype.methodx = function() {
    	...
    }
    // 自定义静态方法
    ObjectName.methods = function() {
    	...
    }
    ```
    
- 在不传递参数时，可以省略构造函数的括号（不推荐这种写法）
- 例子
    
    ```jsx
    let Cat = function (name = "cat") {
      this.name = name;
      this.age = 2;
      this.sayMiao = function () {
        console.log("喵喵，喵！");
      };
    };
    const cat = new Cat;
    console.log(cat); // Cat { name: 'cat', age: 2, sayMiao: [Function (anonymous)] }
    cat.sayMiao() // 喵喵，喵！
    ```
    

## 2.3.2 构造函数也是函数

- 构造函数并没有把某个函数定义为构造函数的特殊语法
- 构造函数也是函数，与普通函数的唯一区别在于调用方式不同
- 任何函数只有使用`new`操作符调用就是构造函数，而不使用`new`操作符调用的函数就是普通函数
- 例如
    
    ```jsx
    function Person(age, name) {
      this.age = age;
      this.name = name;
      this.sayName = function () {
        console.log(this.name);
      };
    }
    const person = new Person(22, "mangwu");
    Person(22, "mangwu");
    console.log(global);
    global.sayName();
    ```
    
    - `person` 实例创建使用`new` 操作符此时`Person` 就是构造函数
    - 然后是直接的`Person()`调用,此时它就是普通函数，`this` 就是当前上下文中的`this`
    - 例如在全局上调用`Person()` `this` 指针就是Global对象，在node环境下是`global`，浏览器环境下是`window`
    - 所以global拥有了`age`和`name`以及`sayName` 属性或方法，如下
        
        ![Untitled](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Untitled%202.png)
        
- 普通函数在调用时可以使用`call()`和`apply()` 指定`this` (关于[apply](../../JavaScript%E5%B0%8F%E8%AE%A1/concat%E5%92%8Capply.md))，所以把形式构造函数的函数通过`call()`，`apply()` 等方法制定`this` ，可以为对象**增加**属性或方法，如下
    
    ```jsx
    const obj = {};
    Person.call(obj, 24, "wumang");
    console.log(obj); // { age: 24, name: 'wumang', sayName: [Function (anonymous)] }
    obj.sayName() // wumang
    ```
    
    - 只有只会增加**自有属性和方法**，不会对原型链有任何影响

## 2.3.3 构造函数的问题

- **相同逻辑的自有方法重复声明耗费性能**
- 构造函数定义的方法在每个实例上都是独一无二的，但是同一个构造函数中定义的方法的逻辑其实是一样的
    
    ```jsx
    // 构造函数的问题
    function Person(age, name) {
      this.age = age;
      this.name = name;
      **this.sayName = new Function("console.log(this.name)");**
    }
    const person = new Person(23, "mangwu");
    console.log(person); // Person { age: 23, name: 'mangwu', sayName: [Function: anonymous] }
    person.sayName(); // mangwu
    ```
    
    - `this.sayName()` 方法使用`Function`构造函数实例化一个方法和之前的函数表达式构造方式是**逻辑等价**的
    - 可以清楚地得知，每个`Person` 实例都有自己的`Function`实例用于显示`name`属性
    - 以这种方式创建函数会带来不同的**作用域链**和**标识符解析**，但是新建`Function`实例的机制是一样的
- 因为`sayName` 都做同样的事情，所以没必要定义两个不同的`Function`实例,况且`**this` 对象可以把函数与对象的绑定推迟到运行时，**解决这个问题，可以把函数定转移到构造函数外部
    
    ```jsx
    function sayName() {
      console.log(this.name);
    }
    function Person(age, name) {
      this.age = age;
      this.name = name;
      this.sayName = sayName;
    }
    const p2 = new Person(23, "mangwu");
    const p3 = new Person(22, "wumang");
    console.log(p2.sayName === p3.sayName); // true
    
    p2.sayName(); // mangwu
    p3.sayName(); // wumang
    ```
    
    - `sayName` 被定义在构造函数外部
    - 在构造函数内部，`sayName`属性等于全局`sayName()`函数， 所以两个实例指向的都是一个外部函数的指针，二者共享定义在全局作用域上的`sayName()`函数
    - 因为`**this` 对象可以把函数与对象的绑定推迟到运行时，**所以实例调用时打印的是对应实例的`name`
- 使用这种方法虽然解决了函数重复定义的问题，但是也带来了新的问题
    - 全局作用域被搞乱了，因为函数实际上只能在一个对象上调用而不能在全局作用域上调用
    - 如果对象需要多个方法，那么全局作用域会定义多个函数，导致自定义类型引用的代码不能很好的聚集在一起
- 下面介绍的原型模式可以完美的解决问题，既不重复函数定义，也不搞乱全局作用域

# 2.4 原型模式

## 2.4.1 基本思想

- **每个函数都会创建一个 `prototype` 属性，**这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法
    
    ![Untitled](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Untitled%203.png)
    
    - `Test`是一个空的函数
    - 它的`prototype`属性对象默认包含两个内容
        - `constructor`属性，属性值为`Test` 函数对象本身
        - [[Prototype]]特性，被赋予`Object`构造函数的`prototype`属性,即`Object`的原型链
- 实际上函数的`prototype`属性就是通过调用构造函数创建的**对象的原型，** 如下是构造函数时底层做的一步
    
    [**这个新对象的内部的[[Prototype]]特性被赋值为构造函数的prototype属性**](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md) 
    
- 使用**原型对象（prototype object）**的好处在于，在它声明定义的属性和方法可以被**对象实例共享**，原来在构造函数中直接赋值给对象实例的值，可以直接赋值给它们的**原型，**例如
    
    ```jsx
    function Person() {}
    Person.prototype.age = 22;
    Person.prototype.name = "mangwu";
    Person.prototype.sayName = function () {
      console.log(this.name);
    };
    const p = new Person();
    console.log(p, p.__proto__); // Person {} { age: 22, name: 'mangwu', sayName: [Function (anonymous)] }
    p.sayName() // mangwu
    ```
    
    - 打印实例`p` 它是空的，因为所有的属性和方法都定义在了构造函数的原型上
    - 构造函数原型会被赋值到实例的[[Prototype]]特性上，这个特性其实就是`__proto__` 属性，所以打印它会显示定义在函数原型上的属性和方法
    - 句点调用实例`p` 的`sayName()`方法，首先会在实例的自有（**own**）属性上查找，如果找不到就到实例的`[[Prototype]]` 特性上找，显然可以找到之前定义的方法；这也是为什么**通过原型模式定义的属性和方法由所有实例共享**的到原因

## 2.4.2 理解原型

- 原型对象的基本规范
    - 无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个`prototype` 属性，该属性指向**原型对象**
    - 默认情况下，所有原型对象自动获得一个名为`constructor`的属性，指向与之关联的构造函数
    - 因构造函数的差异，可能会给原型对象添加其他属性和方法
- **实例与构造函数原型（prototype）之间有直接联系，但实例与构造函数之间没有**
    - 自定义构造函数时，函数的原型对象只会获得`constructor` 属性
    - 函数的原型的其他所有方法都继承自`Object` , 因为**原型对象**的[[Prototype]]特性被赋值`Object`构造函数的**原型**（**prototype**）
    - 每次调用构造函数创建一个新实例，这个实例内部[[Prototype]]特性指针就会被赋值为构造函数的原型对象
    - JavaScript没有规范这个[[Prototype]]特性指针的访问标准方式，但是火狐、Safari、Chrome都会在每个对象上暴露`__proto__` 属性，通过这个属性可以访问对象的原型
- 以上面的[Person](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md)为例子，可视化其原型链
    
    ![原型链.png](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/%25E5%258E%259F%25E5%259E%258B%25E9%2593%25BE.png)
    
    - 声明构造函数`Person` 后，它就有了一个与之关联的原型对象(**Person Prototype Object**)，使用属性`Person.prototype` 指向这个原型对象
    - `Person`关联的原型对象本身也有一个`constructor` 属性引用构造函数，换句话说，原型对象和构造函数**循环引用**
    - 和`Person` 一样，JavaScript内置的`Object` 构造函数也有一个与之关联的原型对象（**Object Prototype Object**）,使用属性`Object.prototype` 指向`Object`的原型对象
    - `Object`的原型对象本身也有一个`constructor` 属性引用`Object`构造函数
    - `Person` 的原型对象的[[Prototype]]特性指针指向`Object` 构造函数关联的原型对象（**Object Prototype Object**）,所有正常的原型链都会终止于`Object` 构造函数的原型对象，而Object原型对象的[[Prototype]] 是`null`
    - 构造函数，原型对象和实例是三个完全不同的对象，构造函数通过`prototype` 关联对应的原型对象，而原型对象和实例通过[[Prototype]]关联原型链上的下一个原型对象，直到Object的原型对象终止，因为Object的原型对象的[[Prototype]]是`null`
    - `[[Prototype]]` 是隐藏特性，在一些JavaScript引擎中，使用`__proto__` 属性表示它，它链接到一个原型对象上
    - **实例与构造函数没有直接联系，与原型对象有直接联系**，实例和构造函数都通过原型链链接对应的原型对象
- 例子
    
    ```jsx
    // 理解原型
    function Person() {}
    // 声明构造函数后，就有了与之关联的原型对象
    console.log(typeof Person.prototype); // Object
    console.log(Person.prototype); // {constructor: *f* Person, [[Prototype]]: Object}
    
    // Person关联的原型对象本身具有constructor属性引用构造函数，二者循环引用
    console.log(Person.prototype.constructor === Person); // true
    // 和Person一样，内置的Object对象也有关联的原型对象，且二者也循环引用
    console.log(Object.prototype.constructor === Object); // true
    
    // Person关联的原型对象的[[Prototype]]特性指针指向Object关联的原型对象
    // 所有正常的原型链都会终止于Object构造函数关联的原型对象，因为它是基类
    // 而Object 原型对象的[[Prototype]]是null
    console.log(Person.prototype.__proto__ === Object.prototype); // true
    console.log(Person.prototype.__proto__.constructor === Object); // true
    console.log(Perosn.prototype.__proto__.__proto__ === null); // true
    
    let person1 = new Person();
    // 构造函数，实例，原型对象是三个完全不同的对象，实例通过[[Prototype]]关联原型对象
    console.log(person1.__proto__ === Person.prototype); // true
    console.log(person1.__proto__.constructor === Person); // true
    
    let person2 = new Person();
    // 同一个构造函数的实例共享同一个原型对象
    console.log(person1.__proto__ === person2.__proto__); // true
    
    // instanceof通过检查实例的原型链是否包含指定构造函数的原型来判断是否是该构造函数的实例
    // 通过[[Prototype]]特性获取原型对象，原型对象中的constructor属性是判断依据
    console.log(person1 instanceof Person); // true
    console.log(person1 instanceof Object); // true
    console.log(Peron.prototype instanceof Object); // true
    ```
    

### 2.4.2.1 检查实例的原型对象

- `Object.prototype.isPrototypeOf()` 方法检查一个对象是否存在于其它对象的**原型链**(**prototype chain**)上,通常调用的对象是某个构造函数管理的**原型对象**(**prototype object**), 而其它对象一般为对象实例
- 语法
    
    ```jsx
    isPrototypeOf(object);
    ```
    
    - 参数 `object` ，一个被检查原型链的对象
    - 返回值，布尔值，如果调用对象位于指定对象（`object`）的原项链上，则返回`true` 否则返回`false`
- **注意**`isPrototypeOf()` 不同于`instanceof` 操作符， ~~`obj instanceof AFunction` 表达式中，`instanceof` 检查对象原型链中是否有函数本身而不是是否包含`AFunction.prototype`~~

> 备注：isPrototypeOf与instanceOf运算符不同，在表达式”object instanceOf AFucntion”中，object'的原型链是针对AFunction.prototype进行检查的，而不是AFunction本身
> 
- 例子
    
    ```jsx
    // 检查对象是否存在于另一个对象的原项链上
    function Person() {}
    
    class Student extends Person {}
    
    const person = new Person();
    const student = new Student();
    console.log(person.__proto__.isPrototypeOf(student)); // true
    console.log(Person.prototype.isPrototypeOf(student)); // true
    console.log(Student.prototype.isPrototypeOf(student)); // true
    console.log(student.__proto__.isPrototypeOf(person)); // false
    console.log(Student.prototype.__proto__.isPrototypeOf(person)); // true
    console.log(Person.prototype.isPrototypeOf(Student.prototype)); // true
    ```
    
    - 原型链是这样的：
        
        <aside>
        ⚪ Student.prototype  → Person.prototype → Object.prototype
        
        ↑                                  ↑                               ↑
        
        student                       person                      object 
        
        </aside>
        
    - `person.__proto___` 等价于 `Person.prototype` , `student.__proto__` 等价于 `Student.prototype`
    - `Student.prototype.__proto__` 等价于 `Person.prototype`

### 2.4.2.2 获取实例对象的原型链

- `Object.getPrototypeOf()` 返回参数的内部特性[[Prototype]]的值，它属于ECMAScript 规范的获取原型链的标准静态方法，只不过在一些JavaScript引擎中，可以直接使用`__proto__` 属性获取对象的原型链
- 语法
    
    ```jsx
    Object.getPrototypeOf(obj)
    ```
    
    - 参数 `obj` 需要获取原型链的实例对象
    - 返回值：`obj` 的[[Prototype]]特性的值，可能为`null` （在`obj`是`Object`构造函数关联的**prototype object**时）
- 例子
    
    ```jsx
    function Person() {}
    const person = new Person();
    console.log(Object.getPrototypeOf(person) === person.__proto__); // true
    console.log(Object.getPrototypeOf(person) === Person.prototype); // true
    console.log(Object.getPrototypeOf(Object.prototype) === null); // true
    ```
    
- 使用`Object.getPorotypeOf()` 方法可以方便的获取一个对象的原项链，这在通过原型实现继承时尤为重要

### 2.4.2.3 重新设置实例对象的原型链

- `Object.setPrototypeOf()` 方法可以向实例的私有特性[[Prototype]]写入一个新值，这样就重写了一个对象的原型继承关系
- 关于使用`setPrototypeOf()` 的警告
    
    <aside>
    ⚠️ 根据现代JavaScript引擎优化属性访问的底层实现，改变一个对象的[[Prototype]]特性值，在每个现代浏览器和JavaScript引擎中都是一个非常缓慢的操作。除此之外，不仅`Object.setPrototypeOf()`语句执行会花费很长时间，改变继承（inheritance）的影响也是微妙（subtle）和广泛的(far-flung)，它影响到任何访问被更改原型链对象的访问速度。关于JavaScript引擎属性访问优化可以查看[JavaScript engine fundamentals: optimizing prototypes](https://mathiasbynens.be/notes/prototypes) 。
    
    因为这个特性是语言的一部分，所以JavaScript引擎开发人员依然有责任将这个接口的性能实现地更加理想。但是在引擎开发者解决这个问题前，如果你关心性能，就不应该使用它来设置对象地[[Prototype]]特性值
    
    </aside>
    
- 语法
    
    ```jsx
    Object.setPrototypeOf(obj, prototype);
    ```
    
    - 参数
        - `obj` 被设置原型的对象
        - `prototype` ：`obj` 对象的新原型，可以是一个对象或`null`
    - 返回值，被设置指定原型的`obj`
    - 抛出错误`TypeError` 的情况
        - 如果`obj` 是**不可扩展的**（**non-extensible**）,或它是一个**不可变原型奇异对象**（**immutable prototype exotic object**），例如`Object.prototype` 或`window`
        - `prototype` 不是一个对象或`null`
    - 如果`obj` 不是一个对象，而是原始数据类型，这个方法什么也不会做
- 安全性
    - `Object.setPrototypeOf()` 是标准的重置对象的原型链的方法，请不要使用`Object.prototype.__proto__` 属性访问修改对象的[[Prototype]] ，该属性不再规范内
    - 为了安全，有些内置对象被设计拥有**不可变原型**（**immutable prototype**）。这是为了防止可能的**原型污染攻击**（prototype pollution attack）,例如浏览器的代理安全问题（**[Proxy-related security](https://github.com/tc39/ecma262/issues/272)**）
        - JavaScript核心语言只会设计`Object.prototype` 是一个**不可变原型奇异对象**，它的原型总是`null`
        - 在浏览器中，`window` 和`location` 也是**不可变原型奇异对象**
- 例子
    
    ```jsx
    	function Person(age, name) {
      this.age = age;
      this.name = name;
    }
    
    Person.prototype.sayName = function () {
      console.log(this.name);
    };
    
    const person1 = new Person(23, "wumang");
    const person2 = new Person(22, "mangwu");
    
    console.log(person1);
    console.log(person2);
    Object.setPrototypeOf(person1, person2);
    console.log(person1);
    console.log(person2);
    console.log(person2.isPrototypeOf(person1)); // true
    ```
    
    - 初始时，`person1`, `person2`拥有相同的结构：
        
        ![Untitled](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Untitled%204.png)
        
        - 和之前的可视化[原型链.png](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md) 类似，实例[[Prototype]]特性指向`Person.prototype` 原型对象，`Person.prototype` 对象的[[Prototype]]特性指向`Object.prototype` 原型对象
    - 执行`Object.setPrototypeOf(person1, person2);` 表示将`person1` 的[[Prototype]]赋值为`person2` ,`person2` 不会发生改变，而`person1` 的原型链会发生改变：
        
        ![Untitled](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Untitled%205.png)
        
        - `person1` 的[[Prototype]]被直接赋值`person2` 所以`person1.__proto__=== person2` 成立，进而`person2` 的[[Prototype]]更准确的是`Person`类型

### 2.4.2.4 初始设置对象实例的原型链

- 为了避免`Object.setPrototypeOf()` 可能造成的性能下降，可以通过`Object`的另外一个静态方法`Object.create()` 创造一个新对象的同时指定原型
- `Object.create()` 使用一个已经存在的对象作为创建的新对象的原型（`prototype`），`Object.create(Object.prototype)` 逻辑等价于 `{}`
- 语法
    
    ```jsx
    Object.create(proto);
    Object.create(proto, propertiesObject);
    ```
    
    - 参数
        - `proto` : 作为新创建的对象的[[Prototype]]特性值，可以是`null`
        - `propertiesObject` : 属性描述符集合，可选，为新创建对象添加**自有（own）**的属性，这个属性和`Object.defineProperties()` 的第二个参数一样的结构，详情查看[1.3 定义多个属性](1%20%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1.md)
    - 返回值
        - 返回一个指定原型和属性的新对象
    - 可能抛出的`TypeError`错误
        - `proto` 可以是对象或`null`
        - `proto` 不能是原始数据类型，或**原型包装类型**（**primitive wrapper objects**）,如`new String("123")`
- **纯净对象：原型是空的对象，**可以通过`Object.create(null)`方式创建，下面页面是对其的介绍
    
    [Object with `null` prototype](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Object%20with%20null%20prototype.md)
    
- 例子
    
    ```jsx
    function Person(age, name) {
      this.age = age;
      this.name = name;
    }
    Person.prototype.sayName = function () {
      console.log(this.name);
    };
    const person = new Person(22, "mangwu");
    
    // 基于person创建新对象
    const student = Object.create(person);
    student.university = "wh university";
    console.log(person);
    console.log(student);
    console.log(Object.getPrototypeOf(student) === person); // true
    console.log(person.isPrototypeOf(student)); // true
    ```
    
    - `person`打印
        
        ![Untitled](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Untitled%206.png)
        
    - `student` 打印
        
        ![Untitled](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Untitled%207.png)
        
    - 可以发现，和`Object.setPrototypeOf()` 方法的功能是类似的，但是只使用`Object.create()` 没有性能的问题

## 2.4.3 原型层级

### 2.4.3.1 访问对象属性的原理

1. 通过对象访问属性，会按照属性的名称进行搜索
2. 搜索开始于对象实例本身（搜索自有属性）
3. 如果在这个示例上发现了给定的名称，则会返回对应的值
4. 如果没有搜索到，会沿着指针进入到对象的[[Prototype]]特性的原型对象中
5. 如果在原型对象上找到属性，就返回该属性值，否则沿着指针进入到原型对象的[[Prototype]]特性的原型对象上
6. 直到找到最底层`Object` 构造函数关联的原型对象 `Object.prototype` ，[因为`Object.prototype.__proto__` 固定为`null`](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md) 
7. 如果找到底层都没有找到该属性，则返回`undefined`
- 上述访问对象属性的原理也是**原型用于在多个对象实例之间共享属性和方法的原因**

### 2.4.3.2 遮蔽（shadow）原型属性

- 虽然可以通过实例读取原型链上的值，但是**不能**通过实例重写这些值
    - 通过`Object.getPrototypeOf()` 或有些引擎实现的`__proto__` 属性可以轻松访问并更改实例原型链上的属性，这里说的不能**不是指**不能实现，而是指这样做是不和逻辑的，非法的
    - 因为通过一个实例修改了原型链上的属性后，其它继承了该原型对象的实例的行为也会发生改变，使得继承这个原型对象的实例不可预测，可能造成灾难性错误
        
        ```jsx
        function Person(age, name) {
          this.age = age;
          this.name = name;
        }
        Person.prototype.sayName = function () {
          console.log(this.name);
        };
        
        const person1 = new Person(22, "mangwu");
        const person2 = new Person(23, "wumang");
        person1.sayName(); // mangwu
        person2.sayName(); // wumang
        // 通过__proto__获取原型对象
        person1.__proto__.sayName = function () {
          console.log(`I'${this.name} and I'm ${this.age} years old.`);
        };
        
        person1.sayName(); // I'mangwu and I'm 22 years old.
        person2.sayName(); // I'wumang and I'm 23 years old.
        ```
        
- **遮蔽**（**shadow**）原型属性指在对象实例上添加一个于原型对象**同名**的**自有**属性，那么这个自有属性会遮住原型对象上的属性
    - 根据[2.4.3.1 访问对象属性的原理](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md) 首先访问对象的自有属性，然后再在原型链上进行搜索
    - 所以定义**同名**的**自有**属性可以屏蔽对原型链上的属性的访问，即使在实例上把这个属性设置成`null`
    
    ```jsx
    // 遮蔽
    person1.constructor = Object; // constructor是Person.prototype原型的一个属性，循环引用Person
    console.log(person2.constructor); // [Function: Person]
    console.log(person1.constructor); // [Function: Object]
    console.log(person1); // { age: 22, name: 'mangwu', constructor: [Function: Object] }
    console.log(person2); // Person { age: 23, name: 'wumang' }
    ```
    
    - `person1.constructor = Object` 并不是修改了原型上的`constructor`属性，而是在`person1`对象上增加了一个自有属性`constructor`
    - 从`person1`和`person2` 的打印直到，`person1` 新增的`constructor` 属性**遮蔽**(**shadow**)了原型上的同名属性
    - 实际上`Person.prototype` 原型上的自有属性`constructor` 也遮蔽了`Object.prototype` 原型上的自有同名属性`constructor` ，因为`Person.prototype.__proto__ === Object.prototype` ，对象实例上的原型对象构成的原型链具有一定顺序，最终是以`Object`构造函数关联的原型对象结束，先访问到的
- 解除**遮蔽**(**shadow**)的方法：使用`delete` 操作符可以完全删除实例上的**自有**属性，从而让标识符解析过程能继续搜索原型链
    - 除非在实例上定义自有属性时设置[[Configurable]]特性是`false`，即[不可配置](1%20%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1.md)
    - 如果想要通过实例直接访问在原型链上顺序上较后的属性，可以将原型链上较前的属性删除，同时需要获取到相应的原型对象后使用`delete` 操作符，因为`delete` 只能删除**自有**属性
    
    ```jsx
    person1.constructor = Object;
    console.log(person2.constructor); // [Function: Person]
    console.log(person1.constructor); // [Function: Object]
    console.log(person1); // { age: 22, name: 'mangwu', constructor: [Function: Object] }
    console.log(person2); // Person { age: 23, name: 'wumang' }
    
    delete person1.constructor;
    console.log(person1); // Person { age: 22, name: 'mangwu' }
    console.log(person1.constructor); // [Function: Person]
    
    // 删除第一个原型对象上的constructor
    delete person1.__proto__.constructor; 
    console.log(person1); // { age: 22, name: 'mangwu' }
    console.log(person1.constructor); // [Function: Object]
    console.log(person1 instanceof Person); // false
    ```
    
    - 可以看到虽然删除了`person1` 上的第一个`constructor` 但是仍然是Person类型，**即`instanceof`不依靠`constructor`判断对象类型**
- 有时候一个对象实例中的某一个属性是否是**自有**属性不清楚，这个时候就能使用`hasOwnProperty()`方法进行判断了
    
    [Obejct.prototype.hasOwnProperty()](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Obejct%20prototype%20hasOwnProperty().md)
    

## 2.4.4 原型和`in`操作符

- 有两种方式使用`in`操作符

### 2.4.4.1 单独使用`in`操作符

- 单独使用时，`in` 操作符可以通过对象访问指定属性时返回`true`
    - 无论属性是在实例上还是在原型上
    - 无论属性是访问器属性还是数据属性
    - 无论属性是可枚举的还是不可枚举的
    - 无论属性是可配置的还是不可配置的
    - 无论属性是符号属性还是字符串属性
    - `in` 操作符都能判断对象是否能访问指定属性
- 例如
    
    ```jsx
    const obj = {
      name_: "mangwu",
      get name() {
        return this.name_;
      },
      set name(val) {
        this.name_ = val;
      },
    };
    Object.defineProperties(obj, {
      // 不可枚举，不可配置
      age_: {
        value: 22,
      },
      // 不可枚举不可配置的访问器属性
      age: {
        get() {
          return this.age_;
        },
      },
    });
    // 可配置可枚举的数据属性
    Object.prototype.sayName = function () {
      console.log(this.name);
    };
    
    Object.defineProperties(obj.__proto__, {
      // 不可配置可枚举的原型链上的访问器属性
      constructor_: {
        get() {
          return this.constructor;
        },
        enumerable: true,
        configurable: true,
      },
    });
    
    console.log("name_" in obj); // true
    console.log("age_" in obj); // true
    console.log("name" in obj); // true
    console.log("age" in obj); // true
    console.log("age" in obj); // true
    console.log("constructor_" in obj); // true
    console.log("constructor" in obj); // true
    ```
    
- 如果要确定某个属性是否在原型链上而**不是**自有属性，可以配合`Object.prototype.hasOwnProperty()`
    
    ```jsx
    function hasPrototypeProperty(obj, prop) {
      return !obj.hasOwnProperty(prop) && prop in obj;
    }
    console.log(hasPrototypeProperty(obj, "constructor_")); // true
    console.log(hasPrototypeProperty(obj, "name")); // false
    console.log(hasPrototypeProperty(obj, "age")); // false
    console.log(hasPrototypeProperty(obj, "hasOwnProperty")); // true
    ```
    

### 2.4.4.3 `for…in`

- 在`for…in` 循环中使用`in`操作符，可以通过对象访问且可以被**枚举**的属性都会被返回，包括实例属性和原型属性
- 因为现在`Object.prototype` 原型对象上的属性都是不可枚举的，所以使用`for…in` 循环获取不到`Object`原型对象的任何属性
- 使用`Object.defineProperty()` 定义在对象上的自有属性可以设置[[Enumerable]]特性值，如果设置成`false`，那么该属性就是不可枚举属性，`for…in` 无法获取，否则是可枚举属性，可以循环获取到
- 例子
    
    ```jsx
    function Person(age, name) {
      this.age = age;
      this.name = name;
    }
    Person.prototype.sayName = function () {
      console.log(this.name);
    };
    
    const person = new Person(22, "mangwu");
    
    Object.defineProperties(Object.prototype, {
      constructor: {
        enumerable: true,
        configurable: true,
      },
      hasOwnProperty: {
        enumerable: true,
        configurable: true,
      },
    });
    
    for (const key in person) {
      console.log(key);
      if (key === "hasOwnProperty") {
        console.log(person[key]("name"));
      }
    }
    // 打印结果
    age
    name
    sayName
    hasOwnProperty
    true
    
    Person.prototype.hasOwnProperty = function () {
      return false;
    };
    for (const key in person) {
      console.log(key);
      if (key === "hasOwnProperty") {
        console.log(person[key]("name"));
      }
    }
    // 打印结果
    age
    name
    sayName
    hasOwnProperty
    false
    ```
    
    - 使用`Object.defineProperties()` 将`Object` 原型对象上的属性设置为可枚举的，测验`for…in` 只能获取可枚举的属性
    - 在`Person` 的原型对象上定义同名的`hasOwnProperty` 属性，它会**遮蔽** `Object`原型对象的同名属性，这种**遮蔽** 不仅仅是访问属性时的，在使用`for … in` 循环获取对象属性时，`Obejct`原型对象上的`hasOwnProperty` 属性不会被枚举出来了，只会枚举`Person`上的`hasOwnProperty` 属性

## 2.4.5 其它获取实例属性的方法

- 除了`for…in` 可以循环遍历实例对象的所有可枚举属性外，还有三个方法可以获取对象的属性，只是限制不同
    - `Object.keys()` 获取对象**自有可枚举**属性构成的数组
    - `Object.getOwnPropertyNames()` 获取对象的**自有普通属性** 构成的数组
    - `Object.getOwnPropertySymbols()` ES6新增符号类型后新增方法，获取对象的自有符号属性构成的数组
- 注意除了`Object.getOwnPropertySymbols()` 和 `in` 的剩下的三种方法都是针对非符号属性的，`Object.keys()` ,`for…in` ，`Object.getOwnPropertyNames()` 都只能获取字符串或数字属性

### 2.4.5.1 `Object.keys()`

- `Object.keys()` 静态方法用于获取对象的**自有（own）可枚举（enumerable）非符号（not-symbol）**属性**名称（names）** ，它们会被按照`for...in` 获取属性一样的顺序构成一个数组用于返回
- 语法
    
    ```jsx
    Object.keys(obj)
    ```
    
    - 参数 `obj` 被获取自有可枚举属性的对象
    - 返回值： 由自有可枚举属性**名称**组成的**字符串数组**
- 注意，参数`obj` 并非强制要是对象
    - 在ES5及之前，传入原始数据类型会报错（`TypeError`）
    - 在ES2015之后，可以传递原型数据类型，它们会被强制转换成对象，但一般只有字符串对象有自有可枚举属性（索引）
- 例子
    
    ```jsx
    let sym = Symbol("123");
    function Person(age, name) {
      this.age = age;
      this.name = name;
      this[1] = 3;
      this[sym] = "123";
      this.sayName = function () {
        console.log(this.name);
      };
    }
    Person.prototype.sayName = function () {
      console.log(this.name);
    };
    
    const person = new Person(22, "mangwu");
    Object.defineProperties(Object.prototype, {
      constructor: {
        enumerable: true,
        configurable: true,
      },
      hasOwnProperty: {
        enumerable: true,
        configurable: true,
      },
    });
    console.log(sym in person); // true
    for (const key of Object.keys(person)) {
      console.log(key); // age name sayName
    }
    console.log(Object.keys(sym)); // []
    console.log(Object.keys("123")); // ['0', '1', '2']
    console.log(Object.keys(123)); // []
    ```
    

### 2.4.5.2 `Object.getOwnPropertyNames()`

- `Object.getOwnPropertyNames()` 静态方法获取对象实例的**自有(own)非符号(not-symbol)**属性
- 语法
    
    ```jsx
    Object.getOwnPropertyNames(obj)
    ```
    
    - 参数，`obj` 被获取自有非符号属性的对象
    - 返回值： 返回`obj` 中自有非符号属性**名称（names）**构成的**字符串数组**
- 注意，参数`obj` 并非一定要是对象，可以是**[原始数据类型](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md)**
- 例子：解释属性排序的问题，字符串属性按照插入顺序排序，数字属性按照大小排序后放在字符串属性前面
    
    ```jsx
    // 获取对象的自有非符号属性构成的字符串数组
    let sym = Symbol("custom");
    const obj = {};
    Object.defineProperties(obj, {
      12: {
        value: "12",
        enumerable: false,
      },
      name: {
        value: "mangwu",
        enumerable: false,
      },
      age: {
        value: 22,
        enumerable: true,
      },
      job: {
        value: "software",
        enumerable: false,
      },
      0: {
        enumerable: true,
        value: "0",
      },
      [3]: {
        enumerable: false,
        value: "3",
      },
      "7": {
        enumerable: true,
        value: 7,
      },
      [sym]: {
        enumerable: false,
        value: sym,
      },
      [10]: {
        value: 10,
        enumerable: true,
      },
    });
    
    console.log(Object.getOwnPropertyNames(obj));
    // 打印
    ['0','3','7','10','12','name','age','job']
    ```
    
- 例子2：获取**不可枚举的自有非符号属性**的方式，先获取所有自有属性，再通过`Object.keys()` 获取可枚举的自有的非符号属性，然后使用`filter` 和`Set` 进行过滤
    
    ```jsx
    // 获取自有不可枚举的非符号属性
    const enumOwnPro = Object.keys(obj); // 仍然使用上面例子的obj
    const enumOwnProSet = new Set(enumOwnPro);
    const allOwnPro = Object.getOwnPropertyNames(obj);
    const nonEnumOwnPro = allOwnPro.filter((v) => !enumOwnProSet.has(v));
    console.log(nonEnumOwnPro); // [ '3', '12', 'name', 'job' ]
    ```
    

### 3.4.5.3 `Object.getOwnPropertySymbols()`

- `Object.getOwnPropertySymbols()` 获取所有**自有的符号属性**
- 语法
    
    ```jsx
    Object.getOwnPropertySymbols(obj)
    ```
    
    - 参数：`obj` 被获取自有符号属性的对象
    - 返回值：包含`obj` 所有自有符号属性的数组
- [注意，参数`obj` 并非一定要是对象，可以是**[原始数据类型](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md)**](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md) 原始类型转换成包装类型的不存在自有的符号属性，所以传递原始数据类型也没有意义
- 例子
    
    ```jsx
    // 获取所有的自有符号属性
    let sym1 = Symbol("sym1");
    let sym2 = Symbol("sym2");
    
    console.log(Object.getOwnPropertySymbols(sym1));
    console.log(Object.getOwnPropertySymbols("123456"));
    
    const obj = {};
    Object.defineProperties(obj, {
      [sym1]: {
        enumerable: true,
        value: "sym1",
      },
      [sym2]: {
        enumerable: false,
        value: "sym1",
      },
    });
    console.log(obj); // { [Symbol(sym1)]: 'sym1' }
    console.log(Object.getOwnPropertySymbols(obj)); // [ Symbol(sym1), Symbol(sym2) ]
    ```
    

## 2.4.6 属性枚举顺序

> ”for-in 循环Object.keys()的枚举顺序是不确定的，取决于JavaScript引擎，可能因浏览器而异“
> 
> 
> ——《JavaScript高级程序程序设计第四版》
> 
- 关于`for-in` 循环寻枚举属性的顺序，MDN其实给出了[解释](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)
    
    <aside>
    💡 现代ECMAScript规范的遍历顺序是，在每个实现（implementations）之间定义良好且一致（consistent）。在原型链的每个组件（component 这里可以指每个原型对象）中，所有非负的整数键（可以是数组的索引）将首先按照升序遍历，然后按属性创建的时间升序遍历其他的字符串键
    
    </aside>
    
- Object.keys()之前解释过，[它们会被按照`for...in` 获取属性一样的顺序构成一个数组用于返回](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md)
- 实际上MDN只给出了`for in`在每个原型对象中属性的遍历方式，没有说明属于不同原型链之间的属性的遍历规则，也就是说，具体的遍历顺序仍然要看JavaScript引擎的实现，只要在每个对象中保持一致即可

---

- `Object.getOwnPropertyNames()` 、`Object.getOwnPropertySymbols()` 和`Object.assign()` 的枚举顺序是确定的
    - 因为它们都只遍历对象的**自有**属性，`Object.assign()` 在合并属性时也是顺序遍历每个对象的可枚举自有属性的
    - 遍历顺序：先以升序枚举数值（非负整数）键，然后以插入顺序枚举字符串和符号键
- 例子
    
    ```jsx
    const obj = {
      1: 1,
      first: "first",
      [Symbol("sym1")]: "sym1",
      second: "second",
      3: 3,
    };
    Object.defineProperties(obj.__proto__, {
      abc: {
        value: 0,
        enumerable: "abc",
      },
      5: {
        value: 5,
        enumerable: true,
        writable: true,
      },
      3: {
        value: 3,
        enumerable: true,
        writable: true,
      },
      0: {
        value: 0,
        enumerable: true,
        writable: true,
      },
    });
    obj[2] = 2;
    obj[Symbol("sym2")] = "sym2";
    obj.third = "third";
    console.log(Object.getOwnPropertyNames(obj)); // [ '1', '2', '3', 'first', 'second', 'third' ]
    console.log(Object.getOwnPropertySymbols(obj)); // [ Symbol(sym1), Symbol(sym2) ]
    for (const key in obj) {
      console.log(key); // 1 2 3 first second third 0 5 abc
    }
    ```
    
    - 从`for…in` 循环只可以看到，node(v18.9.0)环境下
        - 属性遍历的大顺序是：自有属性—→原型对象属性—→原型对象的原型对象属性…
        - 在每个组件（自有属性和原型对象）中的顺序和规范一样[遍历顺序：先以升序枚举数值（非负整数）键，然后以插入顺序枚举字符串和符号键](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md)
    - 所以`0，5`出现在自有属性遍历完毕后但在`abc`之前，并且原型对象中的`3` 因为遮蔽（shadow）无法被遍历到

## 2.4.7 对象迭代

- 对象的迭代就是对对象中键值对的遍历，实际上之前介绍的`Object.keys()` 便是一个对对象的属性进行迭代的静态方法
- ECMAScript 2017新增了两个静态方法用以更好的迭代键值对，它们依据对象内容生成成可序列化的数组，分别是`Object.values()` 和`Object.entries()`
- 对象默认不是可迭代对象，内置对象的`entries()`方法作为可迭代对象的默认迭代器，返回迭代器供`for…of` 使用，但普通对象的`entries()` (包括`values`和`keys()`) 都是返回可迭代的数组

### 2.4.7.1 Object.entries()

- `Object.entries()` 返回给定对象的**自有可枚举字符串属性的[key, value]对构成的数组**。这和`for…in`循环是类似的，只是`for...in` 循环会遍历原型链上的可枚举属性
- `Object.entries()` 的遍历顺序和`for…in` 一样（这就表示和`Object.keys()` 是相同顺序）；如果需要不同的顺序，只需要将返回的数组使用`sort()` 方法进行排序即可，如`Object.entries(obj).sort((a, b) => a[0].localeCompare(b[0]));`
- 语法
    
    ```jsx
    Object.entries(obj)
    ```
    
- 例子
    
    ```jsx
    const obj = {
      a: 1,
      e: 3,
      2: 2,
      1: 1,
    };
    Object.defineProperties(obj, {
      [Symbol("123")]: {
        value: 123,
        enumerable: true,
        configurable: true,
      },
      18: {
        enumerable: false,
        value: 18,
      },
    });
    console.log(Object.entries(obj)); // [ [ '1', 1 ], [ '2', 2 ], [ 'a', 1 ], [ 'e', 3 ] ]
    ```
    
    - 数值属性会被转换为字符串输出，不获取符号属性

### 2.4.7.2 Object.values()

- `Object.values()` 获取对象所有**自有的可枚举的**非符号属性的**属性值，**然后构成数组，数组原型（属性值）顺序和`for…in` 遍历属性的顺序一样（和`Object.keys()`, `Object.entries()` 顺序一样）,与`Object.entries()` 的最大区别就是不获取属性，而是只获取属性值
- 语法
    
    ```jsx
    Object.values(obj)
    ```
    
    - 参数：`obj` 被获取自有可枚举的非符号属性值的对象
    - 返回值：`obj` 对象的自有可枚举的非符号属性值组成的数组
- 例子
    
    ```jsx
    const obj = {
      bar: {
        0: "0",
      },
      10: 10,
      foo: 3,
      2: 2,
    };
    const values = Object.values(obj);
    console.log(values);
    console.log(values[2] === obj.bar);
    ```
    
    - 注意`Object.entries()` 和`Object.values()` 获取到的属性值都是浅复制的

## 2.4.8 其它原型语法

关于原型链写法的一些补充

### 2.4.8.1 重写原型链

- 在给构造函数的原型对象添加一些属性或方法时，一般做法如下
    
    ```jsx
    XXX.prototype.propx = val;
    XXX.prototype.methodx = function() {
    	// 原项对象方法
    }
    ```
    
    - 这种做法没定义一个属性或方法都会重写一遍`XXX.prototype`
    - 虽然代码冗余，但好处是原型对象没有改变，只是修改了原型对象中的属性和方法
- 为了减少冗余，直接通过一个包含所有属性和方法的对象字面量来**重写原型**是一种常见方法
    
    ```jsx
    function Person() {}
    Person.prototype = {
      name: "mangwu",
      age: 123,
      job: "Software Engineer",
      sayName: function () {
        console.log(this.name);
      },
    };
    ```
    
    - `Person.prototype` 被设置为一个通过对象字面量创建的**新对象**
- 和分别添加相比，使用属性和方法是一样的，但有一个问题
    - 重写后，`Person.prototype` 原型对象变成了一个新对象，`**contructor` 属性不指向`Person`** 了（没有`constructor`属性）
    - 在创建函数时，也会创建函数的原型对象，同时自动给原型对象添加`constructor` 属性并赋值函数本身
    - 而通过字面量创建的新对象是不包含`constructor`属性的，访问原型对象的`constructor` 会返回`Object` 关联的原型对象的`contructor` （即`Object`）
    - 虽然`instanceof` 操作符仍然能可靠地判断`Person` 实例的类型，但是开发者不能通过打印依靠`constructor` 属性来判断识别类型了
- 解决方法是在**重写原型**时，专门设置一下`constructor`属性和它的值
    
    ```jsx
    const person = new Person();
    
    Person.prototype = {
      **constructor: Person,**
      name: "mangwu",
      age: 123,
      job: "Software Engineer",
      sayName: function () {
        console.log(this.name);
      },
    };
    const person2 = new Person();
    console.log(Person.prototype.constructor === Person); // true
    console.log(Person.prototype.constructor === Object); // false
    console.log(person instanceof Person); // fasle
    console.log(person2 instanceof Person); // true
    ```
    
    - `person` 被判断不是`Person`类型，因为`person`的[[Prototype]]和当前`Person.prototype` 不是同一个对象，即在`person` 在`Person` 重写原型前被声明，`**person` 的[[Prototype]]指向被重写前的原型**
- 这种方式还有一个小问题，通过字面量定义的`constructor` 属性特性[[Enumerable]]是`true` ，而原生的`constructor` 属性默认是不可枚举的，因此需要使用`Object.defineProperty()`方法定义`constructor`
    
    ```jsx
    Person.prototype = {
      name: "mangwu",
      age: 123,
      job: "Software Engineer",
      sayName: function () {
        console.log(this.name);
      },
    };
    // 恢复constructor
    Object.defineProperty(Person.prototype, "constrcutor", {
      value: Person,
      enumerable: false,
      writable: true,
      configurable: true,
    });
    ```
    

### 2.4.8.2 原型动态性

- 原型动态性指任何时候对原型对象的属性和方法进行的修改都会**动态地**在实例上反应出来
- 这种修改不是重写原型对象，而是在原型对象上进行属性或方法的增删改
    
    ```jsx
    function Person() {}
    // 此时person没有从Person的原型上继承任何方法
    const person = new Person();
    
    try {
      person.sayHi();
    } catch (error) {
      console.log(error.message); // person.sayHi is not a function
    }
    
    Person.prototype.sayHi = function () {
      console.log("Hi");
    };
    person.sayHi(); // Hi
    ```
    
    - `person`实例是在`sayHi` 声明前创建的
    - 在`sayHi` 声明后，`person` 实例就使用它了，这就是原型的动态性体现
- 原型对象上属性增删改动态反应在实例上的原因在于
    - **实例与原型之间松散的关系**
    - 实例和原型之间的链接就是简单的**指针**，而**不是**保存的副本
- 对原型对象的增删改和[重写整个原型](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md)是两回事
    - 实例的[[Prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把函数的原型修改为不同的对象也不会变（除非使用`Object.setPrototypeOf()` 主动设置实例原型）
    - 重写整个原型会切断最初原型和构造函数的联系，但实例引用的仍然是最初的原型
    - 这也验证之前说过的[**实例与构造函数没有直接联系，与原型对象有直接联系**，实例和构造函数都通过原型链链接对应的原型对象](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md)
- 例子：重写构造函数原型对象的可视化过程
    
    ```jsx
    function Person() {}
    let friend = new Person();
    
    Person.prototype = {
      constructor: Person,
      name: "mangwu",
      age: 22,
      sayName() {
        console.log(this.name);
      },
    };
    
    console.log(friend.name);
    try {
      friend.sayName();
    } catch (error) {
      console.log(error.message);
    }
    ```
    
    ![重写原型.png](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/%25E9%2587%258D%25E5%2586%2599%25E5%258E%259F%25E5%259E%258B.png)
    

### 2.4.8.3 原生对象原型（内置对象原型）

- **原型模式是实现JavaScript中所有原型引用类型的模式**
- 所有原生引用类型的构造函数，如`Object`, `Array`, `String`等都在都在原型上定义了实例方法，例如
    - `[Object.prototype.isPrototypeOf()](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md)`
    - `[Object.prototype.hasOwnProperty()](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/Obejct%20prototype%20hasOwnProperty().md)`
    - `[Array.prototype.sort()`](../6%20%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/2%20Array.md)
    - …更多定义在`Array`原型对象上的方法可以查看集合引用类型[2. Array](../6%20%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/2%20Array.md)
    - `[String.prototype.charCodeAt()](../5%20%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/3%203%20String.md)`
    - `[String.prototype.split()](../5%20%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/3%203%20String.md)`
    - …更多定义在`String` 原型对象上的方法可以查看包装引用类型[3.3 String](../5%20%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/3%203%20String.md)
- 通过原生对象的原型可以获取所有默认方法的引用，也可以给原生类型的实例定义新的方法
    - 可以向自定义对象原型一样修改原生对象原型，在原生对象原型上进行增删改
    - 但是**不要重写**原生对象原型，可能造成不可逆的后果
    
    ```jsx
    console.log(String.prototype.startsWith); // [Function: startsWith]
    console.log(Array.prototype.push); // [Function: push]
    String.prototype.isPalindrome = function () {
      for (let i = 0; i < this.length / 2; i++) {
        if (this[i] !== this[this.length - i - 1]) {
          return false;
        }
      }
      return true;
    };
    console.log("12a3a21".isPalindrome()); // true
    console.log("abssbaa".isPalindrome()); // false
    ```
    
    - 在`String` 原型上添加了一个判断字符串是否是回文字符串的方法，当前环境下所有字符串都可以使用这个方法
    - 后面两个字符串在读取`isPalindrome` 属性时，后台自动创建`String`包装实例，从而找到并调用`isPalindrome()`
- **注意**
    - 并不推荐在原生对象原型上进行增删改，即使是简单添加一个自定义方法也不推荐
    - 因为这样可能引发命名冲突，如一个名称在一个浏览器中不存在而在另一个浏览器中存在
    - 另外还可能意外重写原生方法，因为开发者可能并不知道有些好用的方法已被JavaScript引擎实现了
- 推荐的做法
    - 创建一个自定义的类，继承原生类型，就像`[XSet](../6%20%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/6%20Set.md)`

### 2.4.8.4 原型的问题

- 原型**次要**问题是弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值（这个问题很好解决，将一些属性定义为自有属性即可）
- 原型**最大**的问题源自它的**共享特性**
    - 原型上所有属性实例共享，这对函数而已比较合适
    - 对包含原始值的属性也还好，可以通过在实例上添加同名属性来简单遮蔽原型上的属性
    - 真正的问题是来自包含引用值的属性
        
        ```jsx
        function Person() {}
        Person.prototype = {
          constructor: Person,
          name: "mangwu",
          age: 22,
          job: "Software",
          friends: ["wumang", "mangmang"],
        };
        const person1 = new Person();
        const person2 = new Person();
        person1.friends.push("wuwu");
        console.log(person2.friends); // [ 'wumang', 'mangmang', 'wuwu' ]
        console.log(person1.friends); // [ 'wumang', 'mangmang', 'wuwu' ]
        console.log(person1.friends === person2.friends); // true
        ```
        
        - `Person.prototype` 有一个名为`friends` 的属性，包含一个字符串数组
        - 创建两个实例，向其中一个实例的`friends` 属性中添加一个字符串，由于这个`friends` 属性存在于`Person.prototype` 上，新加的字符串也会在另一个实例的`friends` 反映出来（[原型的动态性](2%20%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1.md)）
        - 如果是有意在多个实例间共享数组，没什么问题，但一般而言不同实例应该拥有属于自己的属性副本

注意：JavaScript高级程序设计（第4版）在这的论述其实**只能说明有些属性不适合放在原型里**，更适合作为实例的自有属性，在构造函数里定义
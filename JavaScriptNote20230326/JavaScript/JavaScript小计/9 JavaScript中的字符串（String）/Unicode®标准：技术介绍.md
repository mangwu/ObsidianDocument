# Unicode®标准：技术介绍

# 1. Uncode标准是

## 1.1 基础定义

- Unicode标准是计算机处理中用于表示文本的**通用字符编码标准（universal encoding standard）**
- Unicode的学名为Universal Multiple-Octet Coded Character Set
- Unicode标准的版本和国际编码标准 ISO/IEC 10646 相应的版本完全兼容及同步，任何符合Unicode的实现也都符合ISO/IEC 10646标准
- Unicode标准提供了有关字符和字符使用的附加信息

### 1.1.1 字符集项目

<aside>
💡 注意：ISO/IEC 10646标准设计的字符集项目叫做UCS（Universal Character Set），实际上这个标准和Unicode发布的字符编码标准是一致的，二者在做相同的事情，只不过没有合并；关于不同简写的区别可以见下表

</aside>

| 组织 | 字符集项目 | 标准名称 | 版本 | 国际标准号 |
| --- | --- | --- | --- | --- |
| Unicode联盟（由苹果，Sun，微软，NeXT，施乐等公司共同组成） | Unicode | Unicode® Standard | 从1991发布的Unicode 1.0.0到2022的Unicode 15.0.0 （之后大概每年更新一个大版本，详情查看https://www.unicode.org/versions/enumeratedversions.html） | - |
| ISO（国际标准化组织）和IEC（国际电工委员会） | UCS(Universal Character Set) | UCS（实际上UCS就是Unicode的别名，UCS和Unicode现在都指统一码，或通用字符集） | Unicode 1.1对应于ISO 10646-1:1993，Unicode 3.0对应于ISO 10646-1:2000，Unicode 3.2对应于ISO 10646-2:2001，Unicode 4.0对应于ISO 10646:2003，Unicode 5.0对应于ISO 10646:2003及附录1–3…（详见https://zh.wikipedia.wmmirror.live/wiki/Unicode） | ISO/IEC 10646 |

### 1.1.2 编码方式和实现方式

- Unicode标准的具体落实分为两个层次
    - 第一个就是对世界各国书面语言，符号的进行**编码**；编码意味着编号与字符的对应，也就是通用字符集中编号与字符的一一对应
        - 统一码和ISO/IEC 10646的通用字符集目前使用了**16**位的编码空间，即每个字符占用两个字节(实际应用的统一码版本对应于[UCS-2](https://zh.wikipedia.wmmirror.live/wiki/UCS-2))，理论上可以表示$2^{16} (65536)$ 个字符，但实际并未完全使用这个16位编码，以备特殊使用或将来扩展
        - 16位统一码字符构成**基本多文种平面（Basic Multilingual Plane, BMP），**即仅靠16位的编码空间构成的平面；除了BMP外，Unicode还有16个辅助平面，总共17个片面至少需要21位的编码空间（17需要使用5位表示）
        - 但是实际上，使用辅助平面的字符就会占据4字节的编码空间，与UCS-4保持一致，UCS-4是更大的尚未填充的31位字符集，加上恒为0的首位，理论上可以表示$2^{31}$个字符，完全可以涵盖一切语言符号
        - BMP上字符的编码为U+hhhh，其中h代表一个十六进制数字，与UCS-2编码完全相同，对应UCS-4编码的后两个字节，前两个字节则所有位为0
    
    ---
    
    - 第二个就是编码的**实现方式**，所谓编码的实现方式，指一个字符的Unicode**编码确定**，或者说为了节省空间，以及在不同系统平台的兼容性，不同字符不太可能使用原本在UCS-2或UCS-4中指定的16位或32位编号，需要进一步编码确定；而对统一码或标准字符集中字符编码的**实现**主要依靠**UTF（Unicode Transformation Format，Unicode转换格式）**决定.
        - UTF最早出现于ISO/IEC 10646-1中，它定义了一种UCS转化格式称为UTF-1
        - 如果编码一个仅包含7位的ASCII字符的Unicode文件，如果每个字符都使用2字节的UCS-2字符集进行传输，就会有较大的浪费
        - 可以使用UTF-8编码，它基于**变长编码原则**，将基本7位ASCII字符仍用7位编码表示，占用一个字节（首位补0），而遇到与其它Unicode字符混合的情况，都按照**一定算法**（将对应的统一码进行）转换，转换后字符使用1-3个字节编码，并利用首位为0或1识别
            - 0，则表示是一个占用单字节的字符
            - 1，则可能是使用2-3个字节编码的字符，具体方案查看[wikipedia-UTF-8](https://zh.wikipedia.wmmirror.live/wiki/UTF-8)
        - 类似的，对于未来出现在非BMP平面上的字符，例如”😀“，需要占用4个字节
        
        ---
        
        - 如果使用UTF-16对统一码进行编码（仅限BMP字符），得到的UTF-16编码表示的字符每个都占用两个字节，就没必要考虑节省空间问题；但是如果不进行Unicode编码实现而是直接使用UCS-2对应的统一码，会因为不同设备对**字节顺序的理解不一致**导致字节流识别混乱，所以UTF-16同样按照**一定算法**（将对应的统一码进行）转换；如下是如果使用统一码对BMP区域字符进行识别产生的问题例子分析
            - 例如Mac电脑和个人PC上，某16位字符统一码的二级制表示为4E59，按两个字节拆分为4E和59，在MAC上读取整个字符时是从**低字节开始**的，那么Mac OS会认为此4E59编码为594E，即找到字符“奎”
            - 而在Windows上从高字节开始读取，则编码为U+4E59，即找到字符“乙”
                
                ![字节顺序.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E5%25AD%2597%25E8%258A%2582%25E9%25A1%25BA%25E5%25BA%258F.png)
                
            - 这种情况说明UTF-16的编码顺序若不加以人为定义就可能产生混淆，于是UTF-16编码**实现方式**使用了大端序（Big-Endian，简写为UTF-16 BE）、小端序（Little-Endian 简写为UTF-16 LE）的概念，以及可以附加的**字节顺序记号（BOM）**解决方案
            - 因为windows系统和Linux系统读取字节从高位开始，**UTF-16**编码的实现方式默认使用**UTF-16 LE**

---

- 除了UTF-8，UTF-16外，Unicode的实现方式还包括UTF-7，Punycode，CESU，UTF-32，GB18030等，这些实现方式有些仅在一部分国家或地区使用，有些则是未来的规划方式（UTF-32）
    - 目前通用的实现方式是UTF-16小端序（LE）、UTF-16大端序（BE）和UTF-8
    - 在微软操作系统自带的记事本（notepad）中，另存为对话框可以选择5种方式，除了非unicode编码的ANSI（英文系统就是ASCII编码，中文系统就是GB2321或Big5编码），还有UTF-8，UTF-16 BE，UTF-16 LE，以及待BOM的UTF-8
        - 这个所谓的BOM就是**字节顺序记号**，与标准的UTF-8的区别在于文件开头有没有U+FEFF记号
        - unicode标准允许UTF-8使用BOM，但是不含BOM才是UTF-8的标准，并且在微软外的操作系统使用带BOM的UTF-8编码文件会[产生问题](https://www.zhihu.com/question/20167122)（微软的习惯）
    - 关于UTF各种版本的编码转换可以查看[Unicode和UTF编码转换](https://www.qqxiuzi.cn/bianma/Unicode-UTF.php) 这个网站，如下
        
        ![Unicode.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/Unicode.png)
        
        - 可以发现UTF-16 BE（大端序）的字节顺序记号（BOM）就是前缀U+FEFF，UTF-16 LE（小端序）的字节顺序记号（BOM）就是前缀U+FFFE

## 1.2 unicode用处

- Unicode标准为编码多语言纯文本提供了一种一致的方式，并为文本文件在国际间的交流困难的混乱局面带来了秩序
- 无论是科学家，语言学家，研究人员，使用计算机时都会因为Unicode标准而简化工作；经常使用数学符号和技术符号的数学加和技术人员也会发现Unicode标准的价值
- Unicode标准和ISO/IEC 10646支持三种编码格式（UTF-8，UTF-16，UTF-32），它们使用相同的字符库，这些编码形式允许编码达到一百万个字符（17个平面，1个平面使用16位表示，有65536个字符，共17 * 65536 = 1114112个字符），这足以满足所有已知的字符编码需求，包括历史文字的完全覆盖以及通用的符号系统

## 1.3 unicode设计原则

- Unicode的设计基于ASCII的简单性（**simplicity**）和一致性（**consistency**），但是远远超出了ASCII只能编码拉丁字母的有限能力
- 为了保持字符编码的简单和高效，Unicode标准为每个字符分配了唯一的数值和名称
- 在unicode.org官方网站的[Unicode6.20-ch02](http://www.unicode.org/versions/Unicode6.2.0/ch02.pdf)标识了unicode的十大设计原则
    - Universality（普遍性）：提供单一、综合的字符集，编码一切现代与大部分历史文献的字符
    - Efficiency（高效性）：易于处理与分析
    - Characters, not glyph：字符而不是字形
    - Semantics（语义性）：字符要有良好定义的语义
    - Plain text（纯文本）：仅限文本字符
    - Logical order（逻辑顺序）：默认内存表示是其逻辑序
    - Unification（统一性）：把不同语言的同一书写系统（scripts）中相同字符统一起来
    - Dynamic composition（动态组合）：附加符号（也称变音符号，如`˚`，`¨` 等）可以动态组合
    - Stability（稳定性），已分配的字符与语义不再改变
    - Convertibility（可改变性）：Unicode与其它著名字符集可以精确转换

# 2. Unicode标准包含的字符

## 2.1 当前所有主要语言

- Unicode标准定义了当今所有主要语言中使用的字符的代码，文字包括欧洲的字母文字，中东的从右到左的文字以及许多亚洲的文字

## 2.2 符号

- 除了语言文字之外，Unicode还包括许多符号（Symbols）
    - 标点符号（punctuation marks）
    - 变音符号（diacritics）
    - 数学符号（mathematical symbols）
    - 技术符号（technical symbols）
    - 箭头（arrows）
    - 装饰符号（dingbats）
    - 表情符号（emoji）
    - …等
- 其中变音符号能修改字符标志（character marks），利用Unicode的动态组合特性，变音符号波浪线（~）能与基本符号一起使用来表示重音字母，例如`ñ`
    - 在BMP平面中的波浪线使用一个字节表示，16进制为7e
    - 而能修饰前面字符的波浪线在辅助平面，十六进制为0303，如下
        
        ![辅助平面波浪线.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E8%25BE%2585%25E5%258A%25A9%25E5%25B9%25B3%25E9%259D%25A2%25E6%25B3%25A2%25E6%25B5%25AA%25E7%25BA%25BF.png)
        
- Unicode标准提供了来自世界各地的字母表、书写系统和符号集合共超过13.5万个字符的编码

## 2.2 字符分布

- 大多数符号都在集中在前64K（64千，就是使用16位可以表示的$2^{16}$共65536个编码）个码点（code point）中，这些码点构成的区域称为**基本多文种平面（Basic Multilingual Plane, BMP）**
- 其中还有14个其它的补充平面可供未来产生的字符编码，目前有超过80万个未使用的码点，在未来的Unicode版本中会不断新加字符
- 除此之外，还有两个平面用作**私人使用区**（**Private Use Area，PUA**）
    - 在BMP中也有6400个专用码点
    - 供应商或最终用户可以在内部为它们自己的字符和符号，或者配合专有字体进行使用，如果不够就可以使用私人使用区的131068（`(2 ** 16 - 2) * 2`）个补充专用码元

# 3. 编码和实现形式

- Unicode标准除了定义每个字符的编号或码元外，还定义了该编号或码元以什么位表示（[编码](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md)[方式和实现方式](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md)）
- Unicode标准定义了三种编码形式，允许以字节（byte）、字（word，2个字节）或双字（double word，4个字节）传输相同的数据
    - 所有三种编码形式的字符编码使用相同的共字符库，可以有效地相互转换而不会丢失数据
    - Unicode联盟完全支持使用这些编码形式作为实现Unicode标准的一致方式

---

- UTF-8在HTML和类似协议中很流行，在网络传输中文本数据通常使用UTF-8编码实现
    - UTF-8是一种将所有Unicode字符转换位可变长度字节编码的方法
    - 优点是可以与熟悉的ASCII集合对应，例如26个拉丁，阿拉伯数字，基本标点符号，基本运算符等在Unicode字符的编码和ASCII中具有相同的字节值
    - 并且将Unicode字符转换为UTF-8编码可以在现有许多软件中实现，无需大量软件重写
- UTF-16在许多需要在高效访问字符和节省存储空间之间取得平衡的环境很流行，因为UTF-16编码的字符固定2个字节，可直接根据字符索引确定字节位置，方便快速访问
- UTF-32不关心占用的内存空间，它适用于固定宽度、单个码元就可以访问字符的场景，在使用UTF-32时，每个Unicode字符都是一个32位码元编码的

---

- 所有三种编码形式最多需要4个字节

# 4. 定义文本元素

## 4.1 文本元素

- 书面语言由用于创造单词和句子的**文本元素**（**textual elements**）表示，不同的语言的文本元素不一样，它们可以是字母，如”M”，”e“；也可以是日文假名中用来表示**音节**（**syllables**）的字符，如“わ”，“た”，“し”；也可以是**表意文字**（**ideographs**）中的代表完整单词或概念的字，如中文汉字“我”
- 同时，不同语言的文本元素在不同的编码方式下占用的字节数也是不相同的，如下是表示“我”这个意思的UTF编码实现（日文可以用“私”表示“我”但是读起来仍然是三个音节）
    
    
    ![Me.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/Me.png)
    
    ![我.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E6%2588%2591.png)
    
    ![わたし.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E3%2582%258F%25E3%2581%259F%25E3%2581%2597.png)
    
- 英文的Unicode编码为2个字符（8个字节），但UTF8编码实际使用2个字节
- 汉字的Unicode编码为1个字符（4个字节），但是UTF8编码实际使用3个字节
- 日语假名的Unicode编码为3个字符（12个字节），但是UTF-8编码实际使用9个字节（反而在UTF-16中不包括BOM，仅使用6个字节）

---

- 由此可以得出一个结论，书面语言中的文本元素个数不能简单通过字节数来判断，而需要在确定语言和编码的情况下具体情况分析

## 4.2 文本元素定义变化

- 文本元素的定义通常会发生变化，例如历史上西班牙语排序中，“ll”这个字符作为单个文本元素定义，但是在输入西班牙单词时，“ll”时两个独立的文本元素“|”和“|”
- 为了避免这种文本元素定义变化导致的字符数量混乱，Unicode标准定义了**码元素（code elements）**也就是所说的**字符（characters）**，大多数情况下，码元素对应于最常用的文本元素，以西班牙语的，“ll”为例，Unicode标准将每个”|”定义为单独码元素，将两个“|”组合在一起进行字母排序的任务留给了处理文本的软件

# 5. 文本处理（Text Processing）

- 计算机文本处理（text handling）涉及**加工**（**processing**）和**编码**（**encoding**）
    - 考虑一个打字员在键盘上输入文本
    - 当打字员按下了“T”的组合键（shift+t），计算机的系统软件会接收到一条消息
    - “T”会被编码成U+0054,然后**字处理器**（**word processor**）将整个编码按照一定格式存储在内存中，同时会把它传递给显示软件
    - 显示软件可能是一个窗口管理器或文字处理器本身的一部分，它们负责将字符显示在屏幕上，具体实现为使用字处理器传递的编码数字作为索引查找一个“T”的图像，然后将其绘制在显示器屏幕上
    - 随着打字员输入更多字符，该过程将继续
- Unicode标准只直接**处理**（**addresses**）文本的编码和语义，它不会定义对文本执行的其他操作
    - 例如文字处理器可能会在输入时检查打字员的输入，并以波浪状的下划线显示拼写错误（如微软的word文档）
    - 或者，当它统计自上次换行以来输入的字符到达一定数量时时插入换行符（自动换行）
- Unicode标准的一个重要原则就是**只规范字符能进行正确的编码和解码**（encoding and decoding），而**不会指出**文本处理时的具体执行过程和方式

# 6. 解释字符和渲染字形（Interpreting Characters and Rendering Glyphs）

- Unicode标准虽然定义了字符编码，当时没有定义字形图像，该标准定义了如何解释字符但不会定义如何渲染符号
    - 字符在屏幕上的渲染与显示依靠具体的计算机软件和硬件渲染引擎
    - Unicode标准没有指定屏幕上字符的大小、形状和样式
- Unicode用**码点**（**code point**）标识的字符是一个**抽象实体**（**abstract entity**），例如"LATIN CHARACTER CAPITAL A" 或 "BENGALI DIGIT 5.”（”拉丁字母大写A“或“孟加拉数字5”）；这有别于在屏幕或者纸上做的标记（称为字形），这种字形叫做字符的视觉表现，它因设备不同而有所区别，Unicode不是规范这些的

# 7. 字符序列（Character Sequences）

## 7.1 文本元素不止一个字符

- 一个文本元素可能**不止被编码**为一个字符，它可能会被编码为**一个或多个字符的序列**
- 例如`"c̃"` 这个文本元素，看起来只有一个字符，但实际上，它是由一个基本字母和一个或多个**组合标记（combining marks）**组成的，这些组合标记就是在[字符中所说的字符标记](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md)（character marks），它围绕在基本字母的周围渲染（上面或者下面等）
    
    
    ![标记字符.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E6%25A0%2587%25E8%25AE%25B0%25E5%25AD%2597%25E7%25AC%25A6.png)
    
    - U+0303是辅助平面的一个标记字符，它是一个波浪线
    - 虽然`"c̃"` 看起来就是一个文本元素，但实际上长度为2，即它是由两个字符构成的
    - 使用`split()` 方法可以分割这个文本元素，得到基本字母和组合标记
    - 关于不同语言中的文本如何使用字符序列表示可以查看下面的"Where is my Character?”
    - 关于字形群集（grapheme clusters，最终用户认为的字符）的信息可以查看[UAX#29-Unicode文本分割](https://www.unicode.org/reports/tr29/)
    

## 7.2 字符序列的顺序

- Unicode标准规定了**组合字符序列**（**combining character sequence**）中字符的顺序
    - 最前面是基本字符
    - 后面是一个或多个**无空格的标记**（**non-spacing marks**）
    - 如果有多个无空格的标记，这些标记在排版上没有交互（don't interact typographically），那么这些无空格的标记就不重要了
    - 如果这些标记在排版上确实相互影响，那么它们的顺序就很重要了
- Unicode标准会规范如何将连续的无空格标记应用于基字符上，并说明何时顺序是重要的
    - 当标记字符过多时，会出现“污染屏幕“的状况，如下
        
        B̫̫̫̫̬̭̮̭̭̭̭̭̭̰̰̰  （"\u0042\u032b\u032b\u032b\u032b\u032c\u032d\u032e\u032d\u032d\u032d\u032d\u032d\u032d\u0330\u0330\u0330”）
        
        - 可以发现，下标记添加过多，会遮挡其他文字
        - 如果你在某些网站或聊天软件中接收到了污染屏幕的字符，不要惊讶，它们都是组合字符构成的，可以查看这个[问答了解](https://www.zhihu.com/question/394434460)

## 7.3 预组合字符（precomposed character）

- 查看这两个文本元素：`"ü"`与`"ü"` ,它们看起来是一样的，对吗？
    - 实际上它们两个是**字符构成完全不同**的文本元素，如下
        
        ![ü and ü.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/_and_u.png)
        
    - 第一个`"ü"` 实际上就是上面说的组合字符序列，它的实际Unicode码为\u0075\u0308，即一个基础字母`u` 和一个标记符组成（长度为2）
        
        ![ü.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/u.png)
        
    - 第二个`"ü"` 是**预组合字符**（**precomposed character**），也称为**复合或分解字符**（**composite or decomposable character**），它的实际Unicode码为\u00fc，就是一个在BMP平面的字符（长度为1）
        
        ![ü.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.png)
        
- Unicode标准对预组合字符进行编码是为了兼容早已投入使用的标准（历史遗留问题），例如Latin 1表中包括许多预组合字符，用一个字符显示本该用组合字符展示的文本元素的能力（目前Unicode推荐使用组合字符对需要被修饰的字符进行编码而不是使用预组合字符）

## 7.4 字符分解

- **预组合字符**（**Precomposed characters**）可以**被分解（decomposed）**以符合**一致性（consistency）**或**可分析性**（**analysis**）
- 所谓的一致性或可分析性就是在对字符进行处理时，它的语义应该是可知的
    - 例如文本元素`"ü"` ，它仅由一个预组合字符\u00fc构成，如果不进行分解，与文本元素相关的语义分析就无法进行，例如进行字典**排序**时，与其他诸如`i` 、`u` 的元音字母（汉语拼音中的概念）就不好排序了
    - 一旦字符被分解，字符`"ü"` 就可以被分解为`"u"` 后面跟着非空格字符`"¨"` ，在字符修饰符不影响字母顺序的语言中，字母排序变得更加容易
        
        ![SORT.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/SORT.png)
        
        - 参考上面的`"ü"`与`"ü"` ，一个是**组合字符序列**构成的文本元素，一个是**预组合字符**单独构成的文本元素
        - 排序后后一个`"ü"` （**预组合字符**）排在了最后，但是它应该和前一个`"ü"` 一样排在`"u"` 的后面才是合理的字典排序，这是因为没有进行分解达到`sort()`能语义识别照成的情况（这也是为什么**推荐使用组合字符序列构成文本元素**的原因）

# 8.  Unicode设计原则的语言体现

- Universality（普遍性）
    - 许多现有的国际标准，国家标准和企业标准都被纳入了Unicode标准中，Unicode的前256个字符就取自广泛使用的Latin-1字符集
- Unification（统一性）：把不同语言的同一书写系统（scripts）中相同字符统一起来
    - 通过统一不同语言脚本中的字符，避免字符的重复编码，形式上相同的字符被赋予一个单一的编码
    - 最好的例子就是**中日韩统一表意文字（CJK Unified Ideographs）**，它通过为中文，日文，韩文等（还包括越南文，壮文，琉球文）中的多个共同的表意文字（即汉字）分配一个共同的编码，而不是为每个语言提供单独的编码而实现；因为这三种语言有成千上万个相同的字符，它们属于同一来源
    
    <aside>
    💡 注意：**中日韩统一表意文字（CJK Unified Ideographs）**并没有将所有的汉字都统一起来，至少还有一些本来同源的汉字，却因为某些原因各占用了一个编码位置，最典型的例子就是”**兑**“和“**兌**”
    
    </aside>
    
- Characters, not glyphs：字符，而不是字形
    - Unicode不定义字符的具体样式和形状，所以同一个字符在不同的设备上可以有不同的样式和形状
    - 在语言上的体现，最好的例子仍然是**中日韩统一表意文字（CJK Unified Ideographs）**，参考[维基百科-中日韓統一表意文字#已統一漢字](https://zh.wikipedia.wmmirror.live/wiki/%E4%B8%AD%E6%97%A5%E9%9F%93%E7%B5%B1%E4%B8%80%E8%A1%A8%E6%84%8F%E6%96%87%E5%AD%97#%E5%B7%B2%E7%B5%B1%E4%B8%80%E6%BC%A2%E5%AD%97) ，中日韩三国的语言中的汉字字符，在各自的语言系统中有着不同的写法（但是来源一致，所以编码是一样的），但是具体的渲染与浏览器或查看软件是否安装了相关字体有关
        
        ![cjk.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/cjk.png)
        
- Logical order：默认内存表示是其逻辑序；Semantics（语义性）：字符要有良好定义的语义
    - 有些语言的文本顺序是从右到左的，例如阿拉伯语，Unicode标准为此规范了**具有双向行为的文本**（**text with bidirectional behavior**）的呈现算法
    - 如果一段文本由不同方向的**语言文本元素（scripts）**构成，Unicode标准为此定义了**指定方向变化的字符**。但是文本中字符仍然是按照**逻辑顺序**在**内存**中存储的，所谓的**逻辑顺序**就是文本在键盘中**输入的顺序**
    - 关于文本显示顺序和Unicode双向算法可以查看如下小章

## 8.1 注意-Unicode控制字符及其有关的双向算法（BIDI算法）

参考

[Unicode 控制字符及其有关的双向算法(BIDI算法)](https://www.jianshu.com/p/2073fccfca4f)

[Unicode Bidirectional Algorithm](https://www.unicode.org/reports/tr9/)

### 8.1.1 从例子开始

- 现在都知道，阿拉伯语言是从右向左读的，所以在网页中显示阿拉伯语相关的文本，需要将其文本阅读顺序从右边开始到左边，而不是从左边开始，通常的解决方案就是使用CSS的`direction` 属性设置文本呈现方式，如下
    
    ```html
    <div>你好么？</div>
    <div>How are you?</div>
    <div>كيف حالك؟</div>
     <br>
    <div style="direction: rtl">你好么？</div>
    <div style="direction: rtl">How are you?</div>
    <div style="direction: rtl">كيف حالك؟</div>
    ```
    
    ![text-direction.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/text-direction.png)
    
    - 这样做通常是没有问题的，因为阿拉伯语从右向左阅读`كيف حالك؟` 也是从右向左读的，问号在最左边
    - 使用direction后，问号（这里是阿拉伯问号`؟`，与中文问号`？` 和英文问号`?` 成镜像）仍然在左边，但是中文问号和英文问号从文本的右边到了文本的前面！并且三个文本的文本元素顺序并没有改变
- 如果文本由从左到右阅读的语言文本和从右到左阅读的语言文本组成，那么上面使用direction的解决方案就不能很好的工作了，如下
    
    ```html
    <div>你好么？</div>
    <div>How are you?</div>
    <div>كيف حالك؟</div>
    <div lang="ar"></div>
    <hr>
    <div style="direction: rtl">你好么？</div>
    <div style="direction: rtl">How are you?</div>
    <div style="direction: rtl">كيف حالك؟</div>
    <div style="direction: rtl" lang="ar"></div>
    <script>
      let text = "ه٥晴子" + "middle." + "last." + "❤️";
      const divs = document.querySelectorAll("div[lang='ar']");
      for (const div of divs) {
        div.textContent = text;
      }
    </script>
    ```
    
    - 这里将阿拉伯文字，汉字，英文拼接在一起，得到了一个新字符串文本为`'ه٥晴子middle.last.❤️'` ，按照上面的direction属性进行修饰，文本元素顺序应该不变，只要把相关的标点移到左边，整个文本移到右边就行，但实际上渲染的文本为`❤️.٥last.middle.晴子ه` ,两个阿拉伯文字竟然分开了
    
    ![text-mixed.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/text-mixed.png)
    
    <aside>
    💡 注意，`ه٥` 是两个阿拉伯字符，Unicode编码为：U+0647和U+0665
    
    </aside>
    

### 8.1.2 文本显示顺序和Unicode双向算法

- 想要知道为什么显示会出现问题，应该先了解如下概念

**文本的方向**

- 大多数语言的文本在水平方向都是按照从左到右（Left to Right，LTR）的顺序显示字符的，但也有从右到左（Right to Left，RTL）的顺序显示字符的（阿拉伯语，希伯来语）
- 当然也有按垂直方向书写的文本，比如中国古代的汉字，蒙语就是从上到小，从右到左书写的，不过这里不讨论这种情况，因为非常见情况
- 既然语言有文本方向之分，那么必然会出现两种不同方向的语言混用的情况
    - **双向文本**是指一个同时包含LTR和RTL的文本的字符串文本
    - 现实中，RTL方向的语言通常会夹杂着从左到右的文本（比如阿拉伯语要使用外语、引用、数学、符号等）所以阿拉伯语，希伯来语通常都是双向文本
    - LTR方向的语言是主流，所以很少出现双向文本的情况，但是如果向LTR语言中插入RTL方向的语言，同样会出现双向文本的问题

**逻辑顺序与显示顺序**

- 逻辑顺序在Unicode标准内规定为文本在内存中表示的顺序，而显示顺序就是最终显示在我们面前所看到的文本顺序
- 文本的逻辑顺序和显示顺序并不会完全一致，比如RTL方向的文本，显示顺序为从右到左，但是逻辑顺序可能是从左到右的，逻辑顺序属于计算机底层的问题，我们要解决的是文本的显示顺序问题
    
    ```jsx
    let k = "كيف حالك؟"; // 阿拉伯语，你好吗？
    for(const ch of k) {
      console.log(ch);
    }
    // 这里的打印字符的顺序是从右边开始的，观察؟是最后打印出来的就可以知道
    ```
    
    ![rtl.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/rtl.png)
    
    阿拉伯语的显示顺序是RTL方向的，但是逻辑顺序仍然是从左到右的
    

**Unicode双向算法**

1. 对于双向文本，若不明确文本的显示顺序，在渲染显示时就会出现歧义，为此，需要对双向文本的显示定义一种算法（或者一种规则），用户规范双向文本的显示顺序
2. 通常一种隐式算法（或称为隐式双向排序算法或隐式布局算法）可以定义双向文本的显示顺序
    1. 但是隐式算法不足以产生可供理解的文本
    2. 为此对某些字符的显示顺序需要明确地进行控制，就是使用一系列地[控制符](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md)（类似`HTML`中的元素，也是前面说的[指定方向变化的字符](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md)）来控制字符的显示顺序，这些控制符被Unicode称为**定向格式化字符**
3. 这些**定向格式化字符**不会被显示，显示软件会识别并按照Unicode的规范对**定向格式化字符**后面的字符进行强制渲染顺序变化，它不会对文本的比较、断句、词法分析、数值分析等方面造成影响（逻辑顺序不会变）
4. **Unicode双向算法**（也称为**BIDI算法**）是对隐式算法的扩展，Unicode双向算法定义了定向格式化字符，并定义了一套算法，用于规定这些控制符对需要显示的字符产生怎样的影响
- 一个简单的例子（后续会对定型格式化字符进行详细分类）
    
    ```jsx
    "\u202e123,456,789"
    ```
    
    ![定向格式化字符.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E5%25AE%259A%25E5%2590%2591%25E6%25A0%25BC%25E5%25BC%258F%25E5%258C%2596%25E5%25AD%2597%25E7%25AC%25A6.png)
    
    - `\u202e`是一个控制后续字符从右向左显示的控制符，它本身渲染为空，但是能控制后面的字符的显示顺序变为从右向左
    - 在HTML中`\u202e`会使用转义字符`&#x202e;`表示
    

### 8.1.3 Unicode字符分类

- [除了语言文字之外，Unicode还包括许多符号（Symbols）](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md) 中提到了Unicode中符号的分类，这是基于**语义**的分类

**字符属性**

- 更加正式地，字符的类型的划分形式是多样的，为此，Unicode为字符定义了很多属性，以描述字符
- 比如`Bidi_Paired_Bracket_Type` 属性用于描述字符是开括号（值为`open`）还是必括号（值为`close`）
- 再如`General_Category` 描述字符的通用类别，若该字符是行分隔符，则值为`Line_Separator` ，若是控制符，则值为`Control`

**字符类型**

- 根据字符属性的值可以对字符进行多种方式的划分，字符是具有**方向属性**的，方向**属性的值包含3种类型**，`Unicode`将这三种类型统称为**双向字符类型**，也称为BiDi（**Bidirectional**）类型
- 双向字符类型，它被分为：**强字符**（强类型），**弱字符**（弱类型），**中性字符**（中性类型），
    
    
    | 分类 | 类型（方向性） | 相关字符 | 效果/描述 |
    | --- | --- | --- | --- |
    | 强字符（strong） | Left-to-Right(LTR)，简称L | 从左到右阅读的字符，英语字母，汉字以及世界上大部分从左到右书写的文字 | 方向性确定，和上下文无关，并且可能影响其前后字符的方向性 |
    |  | Right-to-Left(RTL)，简称R | 从右到左阅读的字符，希伯来字母和相关的标点符号；对应的控制符用RLM表示 | 同上 |
    |  | Right-to-Left Arabic，简称AL | 从右到左阅读的字符，阿拉伯语(Arabic)、它拿字母(Thaana)、叙利亚字母，及大多数特定于这些文字的标点符号；对应的控制符用ALM表示 | 同上 |
    | 弱字符（weak） | Left-to-Right (LTR) / Right-to-Left (RTL) | 总的来说，数字和数字相关的字符都是弱类型的，下面是具体的数字细分 | 和强字符一样方向性也是确定的,但是不会影响前后字符的方向性 |
    |  | European Number简称EN | 欧洲数字(European Number) [欧洲数字、东阿拉伯-印度数字，经常使用的数字1，2，3等就是属于EN类型] | 同上 |
    |  | European Separator简称ES | 欧洲数字分隔符，加号，减号 | 同上 |
    |  | European Terminator简称ET | 欧洲数字终止符，度的符号，货币符号，比如，$(美元)，￥(人民币)等 | 同上 |
    |  | Arabic Numerals简称AN | 阿拉伯-印度数字，阿拉伯小数和千位分隔符，平时使用的数字虽然叫做阿拉伯数字，但阿拉伯拥有自已的数字，比如，4的阿拉伯数字字符为٤(u+0664) | 同上 |
    |  | Common Numeric Separator简称CS | 冒号，逗号，句点(即小数点)，不间断空格(no-break space)等，注意：单引号、双引号、分号不属于该类型，中文的句号也不属于该类型 | 同上 |
    |  | Non-Spacing Mark简称NSM | Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md，【Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md 】属性General_Category为以下值的字符：Mn(Non-Spacing_Mark)和Me(Enclosing_Mark)比如，组合用发音字符的上左角 ̚ (u+031A)，西非书面文中的ࣾ (u+08FE) 。 | 同上 |
    |  | Boundary Neutral 简称BN | 中性边界，不是明确给定类型的字符，比如：可忽略的默认值，非字符，控制字符等。比如，广义标点中的不可见乘号(u+2062)就是BN类型 | 同上 |
    | 中性字符 | Neutral | 中性字符，包括大部分标点符号和空格 | 方向性不确定,由上下文环境决定其方向 |
    |  | Paragraph Separator使用B代替 | 段落分隔符[段落分隔符(u+2029)，适当的换行符函数，高级别确定段落的协议] | 同上 |
    |  | Segment Separator简称S | 节分隔符，就是点击Tab按键产生的一段空间隔 | 同上 |
    |  | Whitespace简称WS | 空格，图形空格，行分隔符，换页符，常用标点符号的空格等 | 同上 |
    |  | Other Neutral 简称ON | 其他中性符，所有其他字符，包括对象替换字符，比如，[、]、(、)、"、'、@、&、*、、<、>、|、{、}、;(分号)、!、?、~、=。注意：/ 属于CS类型、%、#属于ET类型 | 同上 |

### 8.1.4 方向性

- 上面弄清除了每个字符基于方向性属性的值分为了**强字符，弱字符和中性字符**三类
- 在具体显示时，Unicode双向算法都能根据**字符属性**和**全局方向**等信息运算并正确显示双向文本（就是前面说的**[隐式算法](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md)**）
- 但是隐式算法不能处理复杂情况下的双向文本，这个时候就需要**[显示模式](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md)**来进行补充，为此要先知道双向文本中方向的确定

**全局方向**

- 全局方向也可称为基础方向，它是一个文本中的总体方向，文本在页面上显示方向运行的顺序取决于主要的全局方向，确定一个文本的全局方向主要靠以下几点
    - 默认从文档（HTML）的左到右继承
    - 如果有相关的`dir` 属性或者`direction` 样式，则根据相应的值指定方向
- [8.1.1 从例子开始](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md) 中的显示的全局方向就是默认从左到右，设置`dir` 或`direction` 样式后变成了从右到左

**方向串**

- 方向串指在一段文本中具有相同方向性的连续字符，这是由于BIDI（隐式）算法产生具有相同方向性的每个连续字符序列的单独方向运行，并且其前后没有相同方向性的其它方向串
- 如下例子
    
    ```html
    <p>ولدت (+86)138-3456-1000</p>
    <p dir="ltr">ولدت (+86)138-3456-1000</p>
    <p dir="rtl">ولدت (+86)138-3456-1000</p>
    ```
    
    - 具体结果
        
        ![direction.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/direction.png)
        
    - 需要注意的是，其中的手机号并不是故意反着输入的，而是按照正常语序输入的，先输入阿拉伯文字（沙特阿拉伯）后，再按照`(+86)138-3456-1000` 的顺序输入，如下
        
        ![阿拉伯文字.gif](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E9%2598%25BF%25E6%258B%2589%25E4%25BC%25AF%25E6%2596%2587%25E5%25AD%2597.gif)
        
    - 有如上输入现象的原因是输入阿拉伯文字（强类型AL）后，整个文本中的全局方向变为**从右到左**（即使手动设置了全局方向dir为ltr，也无法覆盖被强字符影响的中性字符）
    - 弱类型的数字保持了自己本来的方向，而中性字符的括号和`+-` 跟随全局方向（首个强类型文字方向给出的），所以`(` 再输入后变为其镜像`)` 了，`)` 同理，下面是方向串的图（忽略阿拉伯文字的不同，它在本例中只起到）
        
        ![阿拉伯文字方向.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E9%2598%25BF%25E6%258B%2589%25E4%25BC%25AF%25E6%2596%2587%25E5%25AD%2597%25E6%2596%25B9%25E5%2590%2591.png)
        
- 上面的文本被分为7个**方向串，**由于中性字符被全局方向影响，使得原本号码（弱类型AN数字）被拆分成不同的方向串被重写排序，显然现在这种混合的显示方式不是我们想要的，因为阿拉伯人阅读时从右到左，读数字时会理解为`(+68)-831-6543-0001` 这和原本的号码不同，就是作为弱类型固定方向的数字从左到右显示导致的，为此，只需要使用**控制符（\u202e）**将数字强制转换为由右向左的方向即可，如下
    
    ```html
    <p id="special" dir="rtl"></p>
    <script>
    		// \u202c是控制符\u202e的终止符
    		let s = "سالس(+\u202e86)138-3456-1000\u202c";
        const p = document.querySelector("#special");
        p.textContent = s;
    </script>
    ```
    
    - 最终结果：对于习惯从右向左读的阿拉伯人来说，下面第二行是正确的双向文本处理方式
        
        ![控制符.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E6%258E%25A7%25E5%2588%25B6%25E7%25AC%25A6.png)
        

### 8.1.5 定向格式化字符

[为此对某些字符的显示顺序需要明确地进行控制，就是使用一系列地[控制符](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md)（类似`HTML`中的元素，也是前面说的[指定方向变化的字符](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md)）来控制字符的显示顺序，这些控制符被Unicode称为**定向格式化字符**](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D.md) 

<aside>
💡 大部分情况下，Unicode双向算法能根据字符属性和全局方向等信息运算并正确地显示双向文本，这是双方地隐性模式。在这种模式下，双向文本地显示方式基本上由算法完成，不需要人为干预。但是，隐性模式地算法在处理复杂情况的双向文字时会显得不足，这时就可以使用显性模式来进行补充。在显性模式的算法中，除了隐性算法的运算外，可以在双向文本中加入关于方向的Unicode控制字符来控制文字的显示，这些被加入文字的Unicode控制字符在显示界面上是不可见的，也不占用任何显示空间（但是控制符作为一个字符在字符串中还是占用空间的），它会默默影响双向文本的显示

</aside>

**定向格式化字符分类**

- 定向格式化字符作为控制符根据**控制的方式和模式**不一样也可以进一步分类
    - 首先定向格式化字符能分为**隐式（隐性）定向格式化字符**和**显式（显性）定向格式化字符**两大类
    - 其中显式定向格式化字符又分为**显式定向嵌入格式化字符、显式定向重写格式化字符、显式定向隔离格式化字符**，分别简称为**嵌入格式化字符，重写格式化字符，隔离格式化字符**
- 下表是定向格式化字符分类表
    
    
    | 大类型 | 小类型 | 控制符名称 | Unicode代码 | 简述 | 说明 | HTML code |
    | --- | --- | --- | --- | --- | --- | --- |
    | 隐式定向格式化字符 | - | LRM | U+200E | Left to Right Mark | 从左到右的零宽度字符 | - |
    |  | - | RLM | U+200F | Right to Left Mark | 从右到左的零宽度字符 | - |
    |  | - | ALM | U+061C | Arabic Letter Mark | 从右到左的零宽度阿拉伯字符 | - |
    |  |  |  |  |  |  |  |
    | 显式定向格式化字符 | 嵌入格式化字符 | LRE | U+202A | Left to Right Embedding | 把后面的文本看作是从左到右的嵌入 | 在字符串中使用或dir="ltr" |
    |  |  | RLE | U+202B | Right to Left Embedding | 把后面的文本看作是从右到左到右的嵌入 | 在字符串中使用或dir="rtl" |
    |  | 重写格式化字符 | LRO | U+202D | Left to Right override | 强制改变其后文本方向从左到右的重写控制符 | 在字符串中使用或<bdo dir="ltr"> |
    |  |  | RLO | U+202E | Right to Left override | 强制改变其后文本方向从右到左的重写控制符（之前的例子就使用的这个控制符） | 在字符串中使用或使用<bdo dir="rtl"> ；关于bdo标签可以查看https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdo |
    |  | 嵌入和重写的终止符 | PDF | U+202C | Pop Directional Formatting | 嵌入和重写的终止符，用于终止LRE，RLE，LRO，RLO的作用范围 | 在字符串中使用或使用</bdo>  |
    |  |  |  |  |  |  |  |
    |  | 隔离格式化字符 | LRI | U+2066 | Left to Right Isolate | 从左到右地隔离之后的文本 | 在字符串中使用或使用<bdi dir="ltr"> |
    |  |  | RLI | U+2067 | Right to Left Isolate | 从右到左的隔离之后的文本 | 在字符串中使用或使用<bdi dir="rlt"> ；关于bdi标签可以查看https://developer.mozilla.org/en-US/docs/Web/HTML/Element/bdi |
    |  |  | FSI | U+2068 | First Strong Isolate | 隔离之后的文本，文本方向由第一个非嵌套在隔离中的强字符决定 | 在字符串中使用或使用dir="auto" |
    |  |  | PDI | U+2069 | Pop Directional Isolate | 隔离终止符，用于终止LRI，RLI，FSI的作用范围，该终止符还会终止LRE、RLE、LRO、RLO的作用范围 | 在字符串中使用或使用</bdi>  |

**显式和隐式（显性和隐性）**

- 显式和隐式格式化字符都不会显示出来，但是二者仍然有区别
    
    **隐性格式化字符**
    
    - 当使用实体时必须**成对使用**，LRM为从左到右的强字符，RLM为从右到左的强字符，使用它们可以影响被包裹起来的**中性字符方向**，达到控制方向串的目的
    - 在上面的例子中，先输入阿拉伯文字使得显示全局方向变成了从右到左，影响了`()+-` 中性字符，为此可以使用隐式格式化字符LRM将它们包裹，让手机号正确显示为从左到右
        - 如果直接在HTML实体中使用，需要使用`&lrm;` ，这个转义字符就是U+200E这个LRM隐形格式化字符
            
            ```html
            <p>سالس&lrm;(+86)138-3456-1000&lrm;</p>
            ```
            
        - 如果使用HTML-code的方式，可以利用CSS的`dir` 属性设置中性字符的方向，并使用一个内联元素将不同方向的字符分开
            
            ```html
            <p>سالس<span dir="ltr">(+86)138-3456-1000</span></p>
            <p><span dir="ltr">سالس</span>(+86)138-3456-1000</p>
            ```
            
        - 如果要在字符串中使用LRM，就需要使用JavaScript操作HTML元素添加文本了，保证双向文本中使用LRM对应的Unicode即可
            
            ```html
            <p id="special1"></p>
            <script>
              let s = "سالس\u200e(+86)138-3456-1000\u200e";
              const p = document.querySelector("#special1");
              p.textContent = s;
            </script>
            ```
            
        - 结果：总体方向为从左到右，只有阿拉伯部分为局部的从右到左（反向串）
            
            ![隐性格式化字符.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E9%259A%2590%25E6%2580%25A7%25E6%25A0%25BC%25E5%25BC%258F%25E5%258C%2596%25E5%25AD%2597%25E7%25AC%25A6.png)
            
    
    **显性格式化字符**
    
    - 也需要成对使用，但是结束字符是规定好的：RLE,LRE,RLO,LRO的结束字符为PDF；LRI,RLI,FSI的结束字符为PDI
    - 同样的例子，将上面例子中的数字强制转换为从右向左的方向以符合整体从右向左阅读，也可以使用显性格式化字符
        - 直接在HTML实体中使用，需要使用`&#8235;` ,`&#8238;`,`&#8236;` 这三个HTML转义字符分别表示RLE，RLO和PDF
            
            ```html
            <p dir="rtl">سالس(+86)138-3456-1000</p>
            <p dir="rtl">&#8235;سالس(+86)138-3456-1000&#8236;</p>
            <p dir="rtl">سالس&#8238;(+86)138-3456-1000&#8236;</p>
            ```
            
            ![从右到左.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E4%25BB%258E%25E5%258F%25B3%25E5%2588%25B0%25E5%25B7%25A6.png)
            
            <aside>
            💡 注意：只有使用RLO才强制使得数字的方向变成了从右到左，仅使用RLE是没有这个效果的，RLE仅仅是声明一个全局方向为从右到左，这个全局方向影响不了弱字符数字的方向，只能影响中性字符的方向，所以和未使用RLE是一样的效果（这也说明了RLE的等效HTML就是使用`dir="rtl"`）
            
            </aside>
            
        - 在字符串中使用显性格式化字符，保证双向文本中使用RLO，PDF即可对应的Unicode即可
            
            ```html
            <p dir="rtl" id="special2"></p>
            let s2 = "سالس\u202e(+86)138-3456-1000\u202d";
            const p2 = document.querySelector("#special2");
            p2.textContent = s2;
            ```
            
            ![rlo.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/rlo.png)
            
        - ~~但实际上在显示双向文本时，都不使用Unicode，而是使用HTML中等价的标签，RLO格式化字符的等价HTML-code是`<bdo dir="rtl">` ，如下~~
            
            ```html
            <bdo dir="rtl">سالس(+86)138-3456-1000</bdo> <!-- 有误，并不等价于RLO TEXT PDF，而是等价于FSI RLO TEXT PDF PDI -->
            ```
            
            ![bdo.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/bdo.png)
            

**零宽度字符（LRM、RLM、ALM）**

- 所谓的零宽度字符，可理解为在该处插入了一个相应方向的强字符，但该字符是不可见的（宽度为零所以不可见），插入强字符表示它可以**影响周围的中性字符更改方向**，但是对弱字符的方向影响无效果（比如数字）

**与定向格式化字符对应的HTML元素和CSS等效项**

- 在上面的表中提到的HTML code只是简单论述了以下与对应Unicode字符同效果的属性或标签，但是不够全面，没有涉及到CSS
- 需要注意，HTML5没有提供对LRE，RLE，LRO，RLO的精确等效项，但是可以通过CSS来获取LRE、RLE、LRO、RLO、LRI、RLI、FSI的精确等效性
- 在HTML5中`bdi`标签用于对字符进行隔离，类似于FSI TEXT PDI，`bdo` 标签用于强制改变文本的方向，类似于FSI RLO TEXT PDF PDI

<aside>
💡 HTML5和HTML4不同，早期版本的`bdi`元素与LRI、RLI相对应，`bdo` 元素与重写（LRO，RLO）相对应

</aside>

| BIDI算法 | HTML5等效项 | CSS等效项 |
| --- | --- | --- |
| RLI…PDI | dir=”rtl” | direction: rtl; unicode-bidi: isoloate; |
| LRI…PDI | dir=”ltr” | direction: ltr; unicode-bidi: isoloate; |
| FSI…PDI | <bdi>…</bdi>或dir=”auto” | unicode-bidi: plaintext; |
| RLE…PDF | 无对应元素 | direction: rtl; unicode-bidi: embed; |
| LRE…PDF | 无对应元素 | direction: ltr; unicode-bidi: embed; |
| RLO…PDF | 无对应元素 | direction: rtl; unicode-bidi: bidi-override; |
| LRO…PDF | 无对应元素 | direction: lrt; unicode-bidi: bidi-override; |
| FSI RLO…PDF PDI | <bdo dir=”rtl”>…</bdo> | direction: rtl; unicode-bidi: isoloate-override; |
| FSI LRO…PDF PDI | <bdo dir=”ltr”>…</bdo> | direction: ltr; unicode-bidi: isoloate-override; |
- 对上述CSS等效项效果的具体例子
    
    ```html
    <div dir="rtl">● RLI…PDI</div>
    <div dir="ltr">● LRI…PDI</div>
    <div style="unicode-bidi: plaintext">● FSI...PDI</div>
    <div style="direction: rtl; unicode-bidi: embed">● RLE...PDF</div>
    <div style="direction: ltr; unicode-bidi: embed">● LRE...PDF</div>
    <div style="direction: rtl; unicode-bidi: bidi-override">● RLO...PDF</div>
    <div style="direction: ltr; unicode-bidi: bidi-override">● LRO...PDF</div>
    <div><bdo dir="rtl">● FSI RLO…PDF PDI</bdo></div>
    <div><bdo dir="ltr">● FSI LRO…PDF PDI</bdo></div>
    ```
    
    - 结果
        
        ![CSS_控制字符.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/CSS_%25E6%258E%25A7%25E5%2588%25B6%25E5%25AD%2597%25E7%25AC%25A6.png)
        
    - `"●"` 应该属于中性字符,所以也会被BIDI算法影响
    - RLI…PDI ：从右向左阅读的**隔离**格式化控制符，开头的`"●"` 是中性字符，受影响到了右边，但是RLI…PDI是强类型开始的从左到右的方向串不会改变方向
    - LRI…PDI：从左向右阅读的**隔离**格式化控制符，就是默认情况，独立的从左向右的文本
    - FSI...PDI：也是默认情况，因为首个强字符为从左到右的文本，所以这个和上面的一致
    - RLE...PDF：从右到左的阅读的**内嵌**格式化控制符，开头的`"●"` 是中性字符，受影响到了右边，但是RLI…PDI是强类型开始的从左到右的方向串不会改变方向
    - LRE...PDF：从左到右的阅读的**内嵌**格式化控制符，就是默认情况，内嵌的从左向右的文本
    - RLO...PDF：强制地从右到左的阅读的**重写**格式化控制符，开头的`"●"` 是中性字符，受影响到了右边，即使是强类型的从左到右的文本也被影响改变了方向，所以变成了`FDP…OLR ●`
    - LRO…PDF：强制地从左到右的阅读的**重写**格式化控制符，显示上就是默认情况
    - FSI RLO…PDF PDI：强制地从右到左阅读的**独立重写**格式化控制符，因为`bdo` 标签是一个行内元素，宽度是文字宽度，所以文字不会移到页面右边，但是强类型的字符方向改变了，所以变成了`IDP FDP…OLR ISF ●`
    - FSI LRO…PDF PDI：强制的从左到右阅读的**独立重写**格式化控制符，显示上就是默认情况
- 如果将上述的文本换成阿拉伯文字，如下
    
    ```html
    <div dir="rtl">● سنشمؤ </div>
    <div dir="ltr">● سنشمؤ</div>
    <div style="unicode-bidi: plaintext">● سنشمؤ</div>
    <div style="direction: rtl; unicode-bidi: embed">● سنشمؤ</div>
    <div style="direction: ltr; unicode-bidi: embed">● سنشمؤ</div>
    <div style="direction: rtl; unicode-bidi: bidi-override">● سنشمؤ</div>
    <div style="direction: ltr; unicode-bidi: bidi-override">● سنشمؤ</div>
    <div><bdo dir="rtl">● سنشمؤ</bdo></div>
    <div><bdo dir="ltr">● سنشمؤ</bdo></div>
    ```
    
    - 结果
        
        ![阿拉伯文字_CSS.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E9%2598%25BF%25E6%258B%2589%25E4%25BC%25AF%25E6%2596%2587%25E5%25AD%2597_CSS.png)
        
    - 和前面的对比可以发现三处变化
        - FSI...PDI，独立隔离之后的文本，文本方向由第一个非嵌套在隔离中的强字符决定，所以变为了从右向左阅读的文本，显示在右边
        - LRO...PDF，强制地从左到右的阅读的**重写**格式化控制符，显示上`سنشمؤ` 翻转了（变成从左到右了）
        - FSI LRO…PDF PDI，同理，强制的从左到右阅读的**独立重写**格式化控制符，显示上`سنشمؤ` 翻转了（变成从左到右了）

## 8.2 级别串与隔离串序列

### 8.2.1 基本名词

- 嵌入等级：表示字符的嵌入层次，数字越大嵌入越深，在Bidi算法中，字符串中的每个字符都有一个嵌入等级
- 基础方向（base direction）：分段（Bidi算法在对文本进行显示顺序解析时会先进行分段）的方向被称为基础方向，基础方向决定了该段文本从浏览器的左侧还是右侧开始书写
- 隔离启动器：是对LRI、RLI、FSI的统称，注意：隔离启动器不包括PDI
- 嵌入启动器：是对LRE、RLE、LRO、RLO的统称，注意：嵌入启动器不包括PDF

### 8.2.2 级别串和隔离串序列

- 级别串（level run）：也称为方向串（directional run），是指具有相同嵌入等级的字符所形成的最大子串，该子串与其直接接触的前后字符的嵌入等级不相同，比如ab cd RLE ef gh PDF kk mm，假设分段的嵌入等级为0，则字符a、b、c、d（含其中的空格）的嵌入等级都为0，字符e、f、g、h的嵌入等级为1，字符k、k、m、m的嵌入等级为0，该字符串共有三个级别串，分别是abcd，efgh，kkmm
- 隔离串序列：是由一系列级别串组成的序列，其规则如下‘
    - 含有隔离启动器时：除最后一个级别串外，隔离串序列中的每个级别串的最后一个字符是隔离启动器，与该隔离启动器匹配的PDI是序列中下一个级别串中下一个级别串的第一个字符，也就是说，序列中的级别串是以隔离启动器结束的（最后一个级别串除外），以PDI开始的（第一个级别串除外）
    - 无隔离启动器时：此时每个级别串构成一个独立的隔离串序列
- 隔离串序列的特点
    - 每个级别串只属于一个隔离运行序列，也就是说，不存一个运行等级属于两个序列的情形。
    - 在同一个隔离串序列中所有的级别串具有相同的嵌入等级，因为隔离串序列是以隔离启动器开始一个，又以与其匹配的PDI开始另一个运行等级，很明显，这两个级别串具有相同的嵌入等级。
    - 紧随着隔离启动器之后的级别串会开启一个新的隔离串序列，与之匹配的PDI之前的级别串会结束它的隔离串序列
- 隔离启动器的重要规则：隔离启动器和与其匹配的PDI拥有和嵌入级别是提升之前的原始嵌入等级，而不是提升之后的嵌入等级

## 8.3 解决办法

```html
ه٥晴子middle.last.❤️
```

- 这里的٥是阿拉伯数字5，双向字符类型为**从左到右**的弱类型，其也会在从左到右系统输入时才会如上显示
- 如果设置级别方向为从右到左，中性字符`.❤️` 会受到影响从右到左显示，但是中间的汉字和英文是强字符类型，自身仍然从左到右显示，所以最终的显示如下
    
    ![双向文本.png](Unicode%C2%AE%E6%A0%87%E5%87%86%EF%BC%9A%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D/%25E5%258F%258C%25E5%2590%2591%25E6%2596%2587%25E6%259C%25AC.png)
    
    - 将其分成两部分看，一部分是中间的`晴子middle.last` ，它们是不受影响的强类型
    - 而最开始的阿拉伯字符也是强类型，基本方向从右到左，自然在最左边，而`.❤️` 这个部分是中性字符，受基本方向影响也应该从右到左，在最左边显示是正确的，唯一的不确定项是٥，它作为弱类型，但是是**从左到右**的，自然和汉字一样方向不受影响，所以在`晴子middle.last` 的前面

# 9. 分配字符代码

- Unicode标准定义的每个**码元（code element）**都分配了一个数字。这些数字都称为**代码点(code point)**，在文本中引用时，以十六进制形式列在前缀“U+”之后。例如，**代码点**U+0041是十六进制数0041(等于十进制数65)。它在Unicode标准中表示字符“A”
- 每个字符还被分配了一个唯一的**名称**，用于指定它而不是其他字符。例如，U+0041被赋予字符名“拉丁大写字母A（"LATIN CAPITAL LETTER A）”。U+0A1B被赋予了字符名“GURMUKHI LETTER CHA”。这些Unicode名称与ISO/IEC 10646的相同字符名称相同。
- Unicode标准通过字母表将字符分组成块。字母表是任何相关字符的系统。标准在可能的情况下保留源字母表中字符的顺序。传统上，字母表中的字符是按照某种顺序排列的(例如字母顺序)，而Unicode标准则尽可能在码空间中使用相同的顺序排列字符。块的大小差异很大。例如，西里尔字符块不超过256个码点，而CJK表意文字块包含成千上万个码点。
- 字符在代码点范围内按逻辑分组，称为**代码空间（codespace）**。编码从U+0000开始，使用标准的ASCII字符，然后使用希腊文、西里尔文、希伯来文、阿拉伯文、印度文和其他文字；然后是符号和标点符号。**代码空间**继续使用平假名、片假名和汉语拼音字母。统一的汉字之后是完整的现代韩文。代理代码点的范围是为UTF-16保留的。BMP的末尾是一组保留给私人使用的代码点，后面是一组兼容字符。兼容字符是字符变体，仅用于转换到使用了它们的早期标准和旧实现。
- BMP上的代码点范围和两个辅助平面上的非常大的范围保留为私人使用区域。这些代码点没有普遍意义，可能用于特定于某个程序的字符，也可能用于一组用户各自的目的。例如，一组**编舞人员**（**choreographers**）可以为舞蹈记谱设计一组标记系统，并使用用户空间中的码点对标记进行编码。一组页面布局程序可以使用相同的代码点作为控制代码来定位页面上的文本。用户空间的主要意义在于，Unicode标准没有赋予这些代码点任何意义，而是将它们保留为用户空间，并承诺将来永远不会赋予它们任何意义。

# 10. Unicode标准的符合xing

- Unicode标准根据它所体现的原则和编码架构明确规定了一致性的要求。作为最低要求，符合标准的实现具有以下特征。
    - 字符来自 已定义的Unicode**指令表**（**repertoire**）。
    - 字符按照其中一种编码形式进行编码。
    - 使用Unicode语义解释字符。
    - 不使用未分配的码点。
    - 不损坏未知字符。
- Unicode标准的实现只要遵循将字符编码为字节、字或双字（double words）序列的规则，即符合所选择的编码形式，并根据Unicode规范解释字符。在[Unicode标准的最新版本](https://www.unicode.org/versions/Unicode15.0.0/)中可以获得完整的一致性要求。

# 11. 稳定性

Unicode标准还有很大的发展空间，有相当多的**字母表**（**scripts**）将在即将发布的版本中编码。这个过程是严格相加的，换句话说，虽然可以添加字符或定义新的字符属性，但不能删除字符，也不能以不兼容的方式重新解释字符。这些稳定性保证使得以Unicode编码数据成为可能，并期望遵循Unicode标准后续版本的未来实现能够以与遵循该标准早期版本的实现相同的方式解释这些数据。

# 12. Unicode及ISO/ iec10646

Unicode标准与国际标准ISO/ iec10646(也称为通用字符集，简称UCS)非常一致。各委员会之间的密切合作和正式联络确保了对任何一种标准所增加的内容都得到协调和保持同步，从而使两种标准保持完全相同的字符库和编码。Unicode编码形式与ISO/ iec10646中定义的编码形式完全一致。

# 13. 如需更多信息

权威信息可在[最新版本的Unicode标准](https://www.unicode.org/versions/latest/)中找到。该链接将引导您到标准的最新版本。[Unicode标准的更新和勘误表](https://www.unicode.org/errata/)也发布在Unicode网站上。

Unicode网站还包含有关使用Unicode标准的其他技术材料和信息。请参阅[常见问题](https://unicode.org/faq/)、[Unicode词汇表](https://www.unicode.org/glossary/)和[Unicode资源](https://www.unicode.org/resources/)。